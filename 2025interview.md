###	OMD

####	1.CentOS6 和 CentOS7 的区别是什么？

区别如下：

1. 内核版本

   CentOS7的内核版本肯定是要比CentOS6高，前者使用2.6.x，后者使用3.10.x。目前6.5.x

2. 初始化系统

   CentOS6使用传统的init系统来初始化和管理系统服务

   CentOS7引入systemd，这是一个更先进的初始化系统，用于管理系统启动和服务

3. 软件包管理

   CentOS6使用yum作为软件包管理器

   CentOS7同样使用yum，但也支持DNF（yum的升级版，和apt类似）

4. 防火墙

   CentOS6使用iptables作为默认的防火墙管理工具

   CentOS7使用firewalld，这是一个更现代和用户友好的防火墙管理工具

5. 网络配置

   CentOS6使用传统的网络配置工具（ifconfig，network-scripts）来配置网络接口

   CentOS7引入了NetworkManager，这是一个用于管理网络连接的高级工具

6. 文件系统

   CentOS6使用ext4作为默认文件系统

   CentOS7默认使用XFS文件系统，但也支持ext4

   补充：

   - XFS在处理大文件和大容量文件系统时通常表现更好，它对高并发读写操作和大文件的处理能力更强，也支持更大的文件，且支持文件系统快照
   - ext4适用于中小型文件系统chuo

####	2.查看内存和磁盘的命令？

查看内存使用`free -h`（-h:更可读选项），查看磁盘使用`df -h`

```bash
$free -h
               total        used        free      shared  buff/cache   available
Mem:           1.6Gi       452Mi       118Mi       2.0Mi       1.1Gi       1.0Gi
Swap:             0B          0B          0B
```





####	3.说一下linux中的inode?

linux中的inode（index node 索引节点）是一个数据结构，用于存储文件和目录的元数据信息，而不是文件内容本身。每个文件和目录都有一个唯一的inode号，它是文件系统的一个关键组成部分，用于管理文件和目录的访问，权限，时间戳等信息；

1. **元数据信息**：inode包含有关文件或目录的元数据，如文件类型，文件所有者，文件权限，文件大小，文件数据块的位置，创建时间，访问时间和修改时间等
2. **唯一性**：每个inode在文件系统内是唯一的，通过inode号可以找到对应的文件或目录
3. **文件类型**：inode中存储了文件的类型信息，可以表示文件，目录，符号链接和设备文件等
4. **硬链接**：inode还用于跟踪文件的硬链接。硬链接是多个文件名指向同一个inode的情况。
5. **引用计数**：每个inode有一个引用计数，表示有多少个文件名或目录项指向它。只有引用计数为零时，该inode才会被删除，释放相应的磁盘空间。
6. **文件系统表**：操作系统维护一个inode表，记录了文件系统中所有的inode，以便能够快速查找和管理文件和目录。

7. 文件系统创建时，把存储区域分为两大连续的存储区域：inode表和对象的内容数据。每个对象对应一个inode，用一个整数辨识，这个整数是inode号。

8. 目录也是一种文件，打开目录就是打开目录文件，目录文件的结构是一系列***目录项***的列表，每个目录项由两部分组成：所包含文件或目录的名字，以及该文件或目录名对应的inode号码。

9. 创建一个目录时，实际做了3件事：

   1. 在其“父目录文件”中增加一个条目；
   2. 分配一个inode；
   3. 再分配一个存储块，用来保存当前被创建目录包含的文件与子目录。

   被创建的“目录文件”中自动生成两个子目录的条目，名称分别是：“.”和“..”。前者与该目录具有相同的inode号码，因此是该目录的一个“硬链接”。后者的inode号码就是该目录的父目录的inode号码。所以，任何一个目录的"硬链接"总数，总是等于它的子目录总数（含隐藏目录）加2。即每个***子目录文件***中的 `..` 条目，加上它自身的**目录文件**中的 `.` 条目，再加上***父目录文件***中的对应该目录的条目。

10. 这里值得重复一遍，**Unix/Linux 系统内部不使用文件名，而使用 inum 来识别文件**。对于系统来说，文件名只是 inode 号码便于识别的别称或者绰号。

   表面上，用户通过文件名打开文件。实际上，系统内部将这个过程分成三步：

   1. 系统找到文件名对应的 inode 号码
   2. 通过 inode 号码，获取 inode 信息
   3. 根据 inode 信息，找到文件数据所在的 block，读出数据。

11. 由于 inode 号码与文件名分离，这种机制导致了一些 Unix/Linux 系统特有的现象。

    1. 当文件名包含特殊字符，无法正常删除时。可以删除 inode 节点，就能直接删除文件。
    2. 移动文件或重命名文件，只是改变文件名，不影响 inode 号码。所以在 Linux 中移动文件不论大小基本秒成。
    3. 打开一个文件后，系统就以 inode 号码来识别文件，不再考虑文件名。因此，系统无法从 inode 号码得知文件名。

要查看文件或目录的inode号，可以使用：

```bash
$ ls -i filename
123456 filename

# 或

$ stat filename
  File: look
  Size: 206             Blocks: 8          IO Block: 4096   regular file
Device: fc03h/64515d    Inode: 265877      Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1000/      gx)   Gid: ( 1000/      gx)
Access: 2023-09-13 10:53:55.319447481 +0800
Modify: 2023-08-10 09:41:08.857506927 +0800
Change: 2023-08-10 09:41:08.861507086 +0800
Birth: 2023-08-10 09:41:08.857506927 +0800

# Size:文件的实际大小,以字节为单位,直接反映文件中存储的数据大小
# Blocks:文件在磁盘上占用的文件系统块数量，以文件系统块大小为单位
# IO Blocks:是文件系统的块大小，表示文件系统在磁盘上分配存储空间的最小单位

# 使用指定的格式输出
$ stat --format %i filname
267724

```

通过inode号，可以执行以下操作：

1. 查找文件或目录

   ```bash
   find . -inum 123456
   ```

2. 检查硬链接

   硬链接时多个文件名指向相同inode的情况，通过查看文件的inode号，可以确定哪些文件实际上链接到相同的数据块

3. 数据恢复

   如果文件或目录被意外删除，但inode号仍然可用，您可能可以使用专业的数据恢复工具来尝试恢复文件。



查看 inode 占用多少磁盘空间

```bash
df -ih
```





####	4.讲一下硬链接和软链接

硬链接（Hard Link）:

类似 shared_ptr，多个文件名指向同一个inode的情况

1. **目录限制**：硬链接只能用于链接文件，而不能链接目录（特例：根目录的父目录是自己）
2. **跨文件系统**：硬链接不能跨文件系统创建，因为不同的文件系统可能具有不同的inode号
3. **删除文件**：如果删除原始文件，硬链接仍然可以访问数据，只有当所有链接都被删除后，数据块才会被释放
4. **文件更改**：如果更改硬链接的任何一个副本，其他硬链接也会受到影响，因为它们都空闲相同的数据

软链接（Symbolic Link 符号链接）:

软链接创建一个新的特殊文件，该文件包含指向目标文件或目录的路径。软链接是一个独立的文件，其中包含目录的路径信息

1. **物理位置**：软链接和目标文件之间没有直接的物理连接，它们是完全独立的文件。
2. **目录限制**：软链接既可以链接文件，也可以链接目录。
3. **跨文件系统**：软链接可以跨文件系统创建，因为它们只包含路径信息。
4. **删除文件**：如果目标文件被删除或移动，软链接将失效，称为"坏链接"，除非您手动更新软链接的路径。
5. **文件更改**：如果您更改目标文件，软链接不会受到影响，因为它们只是指向目标的路径。

软，硬链接的创建方法：

```bash
# 软链接
ln -s /path/to/myfile mylink	# 注意这里的路径，需要是绝对路径！

# 使用 read -f 可以解析软链接中存储的路径信息
read -f target_link


# 硬链接
ln /path/to/myfile /path/to/link
```

####	5.介绍一下rm的原理

`rm`命令的原理涉及到文件系统的底层机制，其中inode（索引节点）是一个重要概念：

1. **寻找文件**

   根据用户提供的路径或文件名在文件系统中查找要删除的文件，它会搜索目录结构，找到文件对应的inode

2. **检查权限**

   `rm`命令会检查用户是否有足够的权限来删除该文件

3. **释放inode**

   `rm`命令将从目录中删除指向该文件inode的目录项，这样，文件在目录结构中不再可见，但inode本身仍然存在，以防止正在使用文件的进程被中断

4. **减少链接计数（引用计数）**

   每个inode都有一个链接计数，用于跟踪有多少目录项指向它。当 `rm` 命令删除一个目录项时，它会将inode的链接计数减少1。只有当链接计数降至0时，文件系统才会释放该inode，同时释放文件占用的磁盘空间。

   调用**unlink系统调用**，rm多做了一些权限检查的操作，然后调用unlink。

5. **回收磁盘空间**

   一旦inode的链接计数降至0，文件系统就会释放与该inode关联的磁盘块，从而回收磁盘空间以供将来使用。这个过程由文件系统的垃圾回收机制完成。

6. **删除目录项**

   如果删除的是目录，`rm` 命令会从其父目录中删除指向该目录的目录项。这并不会立即删除目录及其内容，只是删除了对目录的引用。如果该目录的链接计数降至0（没有其他目录项指向它），则会递归删除目录中的所有文件和子目录。

在Linux系统中，有一个经典的例子就是通过文件句柄仍然保持打开状态而导致文件被删除但仍然存在于磁盘上。这种情况通常发生在以下情形：

1. **正在使用的日志文件**：如果一个正在运行的进程在某个时刻打开了一个日志文件，并且一直保持着对该文件的句柄引用，即使你使用 `rm` 命令删除了这个文件，文件在磁盘上仍然存在，直到进程关闭了文件句柄。
2. **被挂载的文件系统**：当一个文件位于一个被挂载的文件系统上，而另一个进程正在使用该文件系统，那么即使你在一个文件系统挂载点上执行了 `rm` 命令删除了文件，文件也不会立即从磁盘上删除。这是因为文件系统仍然被挂载着，而挂载点上的文件在文件系统卸载之前不会被真正删除。
3. **网络文件系统（NFS）**：在使用NFS挂载的共享文件系统上，如果某个客户端进程仍然在使用某个文件，即使你在服务器上执行了 `rm` 命令删除了文件，该文件也不会立即从磁盘上删除。





####	6.linux删除一个文件会立即释放空间么？为什么？

不会，Linux的文件系统采用了一种**延迟删除**的策略，延迟删除的主要原因和优势在于：

1. **性能优化**：直接从磁盘上删除数据可能涉及到大量的磁盘I/O操作，而这些操作可能非常耗时，为了提高文件系统的性能，Linux将删除操作延迟到后台处理，以减少删除操作对正在运行的进程和文件系统性能的影响
2. **文件恢复**：如果用户意味删除了文件，延迟删除可以为用户提供一定的机会来恢复这些文件，因为文件实际上并没有立即从磁盘上清除，而是被标记为删除。用户可以使用一些工具来恢复已删除但尚未被覆盖的文件
3. **事务性支持**：延迟删除可以确保删除操作是事务性的，即要么全部执行成功，要么全部失败。这是因为在文件删除时，实际的数据块并没有立即被清除，而是被标记为未使用。这使得在执行删除操作时，可以更容易地回滚事务，以应对错误或异常情况。

具体来说，当你删除一个文件时，Linux文件系统会将文件标记为"已删除"，但它的磁盘空间并不会被立即释放。相反，文件系统会等待合适的时机，在后台的清理过程中释放这些空间。这通常是由文件系统的垃圾回收机制来完成的。



####	7.linux磁盘出现故障，怎么排查

可以按照以下步骤来排除问题：

1. **检查硬件连接**：确保磁盘的电源和数据线连接正常

2. **查看系统日志**：使用系统日志工具（dmesg或journalctl）来查看系统的日志信息，特别关注与磁盘相关的错误消息。这些消息可能包括I/O错误，坏扇区，SMART自检错误等

   *dmesg : display message*

   ```bash
   dmesg | grep -i error
   dmesg --level err
   ```

3. **使用SMART工具**：SMART（自我检测，分析和报告技术）工具可以用来检测硬盘的健康状态。如下：

   ```bash
   smartctl -a /dev/sdX
   ```

   其中，`/dev/sdX`是要检查的磁盘设备名称

4. **检查磁盘分区**：确保磁盘分区表中没有异常或错误，可以使用`fdisk`等工具来查看分区信息

   *fdisk : fixed disk*

   ```bash
   # 查看所有已连接磁盘的分区信息;包括分区的设备名称、分区大小、文件系统类型等
   sudo fdisk -l
   ```

5. **查看文件系统状态**：可以使用文件系统检查工具（如`fsck`）来检查和修复文件系统错误

   *fsck : file-system check*

   ```bash
   fsck /dev/vda
   ```

6. **检查磁盘空间**：确保磁盘没有用尽空间

   *df : disk free*

   ```bash
   df -h
   ```

7. **尝试重新挂载**：有时，卸载并重新挂载文件系统可以解决一些临时性的磁盘问题。

   ```bash
   umount /dev/sdXY
   mount /dev/sdXY /mnt
   ```

8. **查看硬盘信息：**

   *lsblk* : *list block devices*

   ```bash
   # 以树状格式列出所有存储设备,包括分区信息
   $ lsblk
   vda    252:0    0    40G  0 disk 
   ├─vda1 252:1    0     1M  0 part 
   ├─vda2 252:2    0   200M  0 part /boot/efi
   └─vda3 252:3    0  39.8G  0 part /
   
   # 有关文件系统的输出信息
   $ lsblk -f
   NAME   FSTYPE   FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
   vda                                                                             
   ├─vda1                                                                          
   ├─vda2 vfat     FAT32       B30A-DE2A                             190.9M     3% /boot/efi
   └─vda3 ext4     1.0         f35d2070-cd93-4d75-b339-c93bd9cfa66d     24G    34% /
   ```

   

9. 查看 /etc/fstab 文件，查看自动挂载配置是否正确，检查分区的 UUID

   



####	8.linux命令，如何查看连接的其他主机ip？

`netstat` 命令将显示当前系统上的网络连接，包括本地地址和远程地址。

```bash
netstat -tuln
# -t : 显示TCP连接
# -u : 显示UDP连接
# -l : 仅显示侦听连接，这些是本地服务器等待传入连接的连接
# -n : 以数值形式显示IP地址和端口号，而不是尝试将它们解析为主机或服务名称

netstat -tn | grep -i established
# 查看状态是 established
```

推荐使用 `ss`

`ss` 查询速度更快，能提供更多信息（定时器），可以按状态筛选。

`netstat` 在 Linux 2.6.32之后被标记为 **"deprecated"（弃用）**

```bash
ss -tn4p -o state established 

# -n：以數值的方式顯示連接埠，不要解析為服務名稱。
# -r：將 IP 位址解析為主機名稱。
# -l：列出傾聽狀態（listening）的 sockets。
# -a：顯示所有的 sockets，包含傾聽狀態（listening）與非傾聽狀態（non-listening）。
# -t：只列出 TCP 的 sockets。
# -u：只列出 UDP 的 sockets。
# -x：只列出 Unix 的 sockets。
# -4：只列出 IPv4 的 sockets。。
# -6：只列出 IPv6 的 sockets。。
# -p：顯示使用 sockets 的程式資訊。
# -e：顯示 sockets 細部資訊。
# -i：顯示 TCP sockets 內部資訊。
# -o：顯示 sockets 的計時器（timer）資訊。
# -s：輸出 sockets 的使用統計表。

# ss -o state fin-wait-1 '( sport = :http or sport = :https )' dst 12.34.56.0/24
```

`ss` 包含于 iproute2，相比于 net-tools，替代的命令如下：

![Arch LInux | 网络管理工具iproute2（网络接口、ip地址、路由表）_archlinux](https://s2.51cto.com/images/blog/202204/07001319_624dbc1f18fc292965.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184)



####	9.如何查看进程占用资源？

1. top 和 ps aux 全局查看

2. 使用 pgrep，通过进程名字拿到进程号

3. 使用pidstat -u -r -p  <PID> ，查看指定指定进程的CPU和内存统计信息

4. 通过/proc文件系统，cat /proc/<PID>/status 来查看进程的详细信息

```bash
$ pidstat -urdw --human -p $(pgrep process_name)
# -r : 报告页面错误和内存利用率
# -d : 报告 I/O 统计信息
# -u : 报告 CPU 使用率
# -w : 报告任务切换活动(上下文切换)	
# --human : 以人类可读格式打印大小
```





####	10.acl与安全组的区别？

1. ACL（Access Control List）

   - **位置：** ACL通常在路由器、防火墙或子网级别配置。它可以用于控制进出网络的流量。
   - **规则：** ACL使用规则列表，这些规则基于源IP地址、目标IP地址、协议和端口号等标准匹配流量，并根据规则决定允许或拒绝流量。
   - **状态：** ACL通常是**无状态**的。这意味着它不维护有关连接状态的信息。每个数据包都被独立地处理，ACL不会跟踪数据包之间的关系。
   - **复杂性：** ACL的规则可以变得非常复杂，特别是在大型网络中，管理和维护ACL可能需要耗费大量时间和精力。

2. 安全组（Security Group）

   - **位置：** 安全组通常在云计算平台（如AWS、Azure、Google Cloud等）中使用，用于控制虚拟机实例之间和虚拟机实例与其他资源之间的网络流量。
   - **规则：** 安全组使用规则列表，类似于ACL。规则基于源IP地址、目标IP地址、协议和端口号匹配流量，并决定允许或拒绝流量。
   - **状态：** 安全组是有状态的。这意味着如果您允许从实例A到实例B的流量，响应流量也会被允许，无需单独的规则。
   - **动态性：** 安全组规则可以根据需要进行动态调整，以适应应用程序的变化。

   **区别和有状态与无状态的区别：**

   - 主要区别在于安全组通常用于云计算平台中，而ACL更常见于传统的物理网络设备中。
   - ACL通常较复杂，可以用于更广泛的网络控制，而安全组是云平台特定的，并且相对简单，用于控制虚拟资源之间的流量。
   - 安全组是有状态的，可以更轻松地管理规则，而ACL通常是无状态的，每个数据包都独立处理。
   - 安全组通常更适用于云环境中的弹性和自动化，因为它们可以自动应用到新创建的资源上。



####	11.linux基本的命令，查找指定内存范围的文件，查看文件的大小。

查看文件大小：

```bash
# 使用 stat 可以显示文件大小已经文件系统信息
stat myfile

# 使用 ls
ll -h myfile	# 文件的实际内容所占大小, -h : 可读形式显示大小

# 最佳方法
du -h myfile	# 所占文件系统中的大小
```

查找指定大小范围的文件，并设置查找的递归层数

```bash
find . -maxdepth 1 -size +500k -size -1M
```

扩展一下find：

查找匹配通配符的文件

```bash
find . -name '*.md'
```

查找匹配多个路径/名称模式的文件

```bash
find . -path '*/path/*.md' -or  -name '*.pdf'
```

忽略大小写进行查找

```bash
find . -type d -iname 'document'
```

查找给定模式匹配的文件，不包括特定路径

```bash
find . -name '*.h' -not -path '*/include/*'
```

为每个文件运行命令

```bash
find . -name '*.c' -exec wc -l {} \;
```

查找空的文件并删除它们

```bash
find . -type f -empty -delete
```

查找最近七天内修改的文件

```bash
find . -daystart -mtime -7
# -daystart 将起始时间设置为当日的00:00:00
# -mtime -mmin 查找过去n天或n分钟内修改过的文件
# -ctime -cmin 查找过去文件属性被修改
# -atime -amin 查找过去访问过的文件
```



####	12.Linux 防火墙配置 禁用一个ip，禁用某个TCP 端口，聊天框打出来，iptables 会吗？

一般可以使用firewall-cmd 或 iptables来配置，如使用iptable：

禁用特定IP：

```bash
# 将规则添加到IP链策略
sudo iptables -A INPUT -s <ip_address> -j DROP

# 将规则添加到考虑协议和端口的IP链策略
sudo iptables -A INPUT -s <ip_address> -p <protocol> --dport <port> -j DROP
```



将目的ip是192.168.122.1，目的端口号是80的报文更改为目标ip是192.168.1.1，目的端口号是8080：

```bash
sudo iptables -t nat -A PREROUTING -p tcp -d 192.168.122.1 --dport 80 -j DNAT --to-destination 192.168.1.1:8080
```



四表五链：

- 四表：

  - **filter表**：这是默认的表，用于管理防火墙规则，允许你定义哪些数据包可以通过、被丢弃或被拒绝。
  - **nat表**：这个表用于网络地址转换 (NAT) 规则，允许你配置端口转发和地址转换规则。这对于实现端口重定向、负载均衡和隐藏内部网络拓扑结构非常有用。
  - **mangle表**：这个表允许你修改数据包的特定字段，如 TTL (Time To Live) 值，负载均衡标记等。
  - **raw表**：这个表允许你配置连接跟踪规则，通常用于配置连接跟踪的参数。

- 五链：

  - **INPUT**：此链用于处理接收到的数据包，通常用于设置允许或拒绝进入系统的数据包。

  - **OUTPUT**：此链用于处理从系统发送的数据包，允许你设置数据包从系统发出时应用的规则。

  - **FORWARD**：此链用于处理通过系统路由的数据包，通常用于防火墙或路由器上。

  - **PREROUTING**：这个链是nat表中的一个链，用于在数据包到达任何其他链之前修改数据包。通常用于**目标地址转换。**

  - **POSTROUTING**：这个链是nat表中的一个链，用于在数据包离开系统之前修改数据包。通常用于**源地址转换。**

    





简述iptables的用法和原理：

iptables基于一系列规则和规则链来控制网络数据包的流动。

1.核心概念：表Tables，链Chains，规则Rules，目标Targets，默认策略Default Policies

- 表：表存储规则，常见表包括filter（过滤数据包），nat（网络地址转换），mangle（修改数据包头信息）等。
- 链：表中包含多个链，每个链包含一组规则。常见的链有：`INPUT`，`OUTPUT`，`FORWARD`等。
- 规则：由管理员定义的规范，它们决定了数据包的处理方式。通常由匹配条件和目标组成。匹配条件可以是源，目标IP，协议类型，端口号等，目标定义了数据包匹配条件后的处理动作，如接受，拒绝，转发等
- 目标：目标定义了规则匹配后要执行的动作。常见的目标包括：`ACCEPT`，`DROP`，`REJECT`，`SNAT`，`DNAT`，
-  默认策略：每个链可以有一个默认策略，规定了当没有规则与数据包匹配时应该采取的动作。默认策略通常是 `ACCEPT` 或 `DROP`。

2.基本用法：

- **查看规则**

  使用`iptables -L`命令查看当前防火墙规则

  ```bash
  sudo iptables -nL
  
  # 查看不同的表
  sudo iptables -nL -t nat
  ```

  

- **添加规则：** 使用 `iptables -A` 命令添加规则到规则链的末尾或`iptables -I`在指定位置之前插入

  ```bash
  # 允许来自TCP端口80的流量
  iptables -A INPUT -p tcp --dport 80 -j ACCEPT
  ```

  

- **删除规则：** 使用 `iptables -D` 命令删除规则。

  ```bash
  # 删除INPUT链中的第2条规则
  iptables -D INPUT 2
  ```

  

- **清空规则：** 使用 `iptables -F` 命令清空规则链上的所有规则。

- **永久生效：**

  ```bash
  service iptable save
  service iptable restart
  ```

  



####	13.“用shell脚本把一个文件倒数第二列打印，以空格分隔，聊天窗口打出来”，“求个倒数第二列的和呢？”



本问答案：

```bash
echo $(awk '{print $(NF-1)}' file.txt)

awk '{sum+=$(NF-1)} END {print sum}' file.txt
```

最新最优版本：

```bash
# 使用 printf
awk '{printf "%s ", $(NF-1)} END {printf "\n"}' fileName
```

**在 awk 中，注意 print 和 printf 的区别：**

1. print：

   print 是 awk 中输出行的基本命令，以默认格式输出所有参数，并在每个参数之间插入一个空格，并且会在输出的最后添加一个换行符。

2. printf:

   printf 允许你使用格式化字符串来指定输出的格式，类似 C 语言。你可以使用 `%` 占位符指定不同类型的输出，以及控制字段的宽度和精度。



awk是一种按行处理的文本处理工具，可以对数据进行分析，过滤和转换，其语法结构大概如下：

```bash
awk 'pattern { action }' input-file
```

常用方法：

打印每行的行数和字段数

```bash
# 重要变量 NF (number-field), NR (number-rows)
awk '{print "Line:", NR, "Fields:", NF}' filename
# NF 会打印该行有多少个字段， 加上 $NF 则会打印最后一个字段的内容
```

打印包含foo行的第二列

```bash
awk '/foo/ {print $2}' path/to/file
```

打印每行的最后一列，使用`,`为分隔符

```bash
awk -F ',' '{print $NF}' path/to/file
```

累加每行第一列的值，并打印出来

```bash
awk '{s+=$1} END {print s}' path/to/file
```

根据条件打印不同的值

```bash
awk '{if($1 == "foo") print "C1"; else if($1 ~ "bar") print "C2"; else print "C3"}' path/to/file
```



根据某一列的值来打印整行

```bash
awk '($10 >= min_val && $10 <= max_val)'
```

从第一行开始，每三行打印一行

```bash
awk 'NR%3==1' path/to/file
```



向AWK脚本传递外部变量

```bash
# -v varname=value
for (( i=1; i<=n; ++i )); do
	awk -v col=$i '{print $col}' file.txt
done
```



**如何打印文件的第 n 行？**

```bash
awk -v n="$n" 'NR==n{print; exit}' "$file_name"
```







####	14.cgroup和namespace介绍

cgroup (Control Group) 和 namespace 是linux操作系统中用于容器化的两个核心特征，它们分别负责资源管理和隔离，使得容器可以独立运行，互补干扰。

Cgroup：

- 作用：主要用于控制和管理系统中的进程组，运行你限制，分配和监视资源，如CPU，内存，磁盘I/O等。确保不同的进程组在系统上不会争夺资源，从而实现资源隔离。

Namespace：

- 作用：主要用于隔离进程，使得不同的进程组在不同的命名空间中运行，相互之间不会感知到对方的存在，从而实现进程级别的隔离。



####	15.TCP 四层挥手讲一下

![TCP关闭图.png](https://wiki.wireshark.org/uploads/__moin_import__/attachments/TCP-4-times-close/TCP-close-diagram.png)

1. 客户端向服务器发送完成数据报，表明客户端将关闭客户端到服务器的传输，这称为主动关闭。（FIN=1，seq=u）
2. 服务器确认FIN数据报
3. 服务器继续传输，如果服务器完成传输，将关闭从服务器到客户端的传输，这称为被动关闭
4. 客户端向服务器确认FIN数据报

发送ACK后，客户端不会立即释放资源，而是进入TIME-WAIT状态，等待2-MSL（Maximum Segment Lifetime）时间来释放资源

![img](https://images2015.cnblogs.com/blog/823435/201703/823435-20170323092953893-1865298744.png)

补充，TCP 中共有 11 种状态，如下：

<img src="C:\Users\46823\AppData\Roaming\Typora\typora-user-images\image-20240301160733489.png" alt="image-20240301160733489" style="zoom:80%;" />





![image-20240305152623293](C:\Users\46823\AppData\Roaming\Typora\typora-user-images\image-20240305152623293.png)

![img](https://img2018.cnblogs.com/blog/831017/201812/831017-20181217222349180-728581576.png)



![img](https://cdn.fasionchan.com/p/39b4247a4dea3d460832c67f8791ca06d1b72753.png)



####	16.为什么第四次挥手后要等待2MLS秒才进入closed状态

1. 如果客户端发送ACK报文，直接关闭连接。假设ACK报文丢失，服务器将永远不会收到ACK报文从而无法关闭连接，造成服务器的资源的泄露。
2. 正确处理迟到的报文



####	17.为什么服务端要先发送ACK，再发送FIN

需要响应客服端的关闭请求，否则客户端将等待一段时间后超时重发FIN，增加了关闭连接的时间。

1. 避免客户端超时：需要响应客户端的FIN，否则客户端在等待一段时间后超时，这可能导致客户端重新发送FIN，从而增加了关闭连接的时间
2. 服务端发送剩余数据：服务端发送ACK来确认收到客户端的FIN请求，然后继续发送剩余的数据
3. 保持连接的可靠性：
4. 





####	18.TCP滑动窗口有了解吗

滑动窗口主要用于流量控制（flow control）。

- TCP接收方利用自己的接收窗口大小来限制发送方发送窗口的大小
- TCP发送方收到接收方的**零窗口通知**后，应启动**继续计时器**（应对接收方重设接收窗口报文丢失，发送方等待非零窗口通知，接收方等待发送方发送数据这种**相互等待**的**死锁局面**）。继续计时器超时后，向接收方发送**零窗口探测报文**（带重传计时器，如果丢失可以重传）。接收方收到后进行确认并通告自己的接收窗口。
- 



####	19.UDP如何确定自己发送给谁

通过目的IP地址和目的端口号



####	20.UDP如何保证可靠传输





####	21.浏览器拿到`www.baidu.com`响应的过程

1. **域名解析**：
   - 浏览器首先会检查自身的DNS缓存，看是否已经解析过`www.baidu.com`。如果已解析，浏览器会直接使用缓存的IP地址。
   - 如果未解析，浏览器会向本地操作系统的DNS解析器发起请求，询问`www.baidu.com`的IP地址。
   - 如果本地DNS缓存中没有该域名的记录，解析器会向根域名服务器发起请求，逐级查询，直到找到对应的IP地址。通常，本地DNS服务器会缓存这些信息，以加快将来的解析过程。
2. **建立TCP连接**：
   - 一旦浏览器获得了`www.baidu.com`的IP地址，它就会尝试与该IP地址上的Web服务器建立TCP连接。这通常涉及到进行三次握手，以确保连接的可靠性。
3. **发送HTTP请求**：
   - 一旦TCP连接建立成功，浏览器会构建一个HTTP请求，其中包括请求的方法（通常是GET）、请求头、可能的请求体等信息。
   - 这个HTTP请求将被发送到`www.baidu.com`的Web服务器。
4. **服务器处理请求**：
   - 服务器接收到HTTP请求后，会根据请求的内容执行相应的处理。在这个例子中，服务器会处理`www.baidu.com`的请求并生成一个响应。
5. **发送HTTP响应**：
   - 服务器生成HTTP响应，包括响应头、响应体等内容。
   - 服务器将HTTP响应通过之前建立的TCP连接发送回浏览器。
6. **浏览器渲染**：
   - 浏览器接收到HTTP响应后，会解析响应头和响应体。
   - 如果响应头指示了资源的类型（如HTML、CSS、JavaScript、图片等），浏览器会相应地处理它们。
   - HTML内容会被解析和渲染成可视化的网页，其中包括文本、图像、链接等。
7. **页面加载**：
   - 页面的HTML内容被解析后，浏览器会开始加载页面中引用的其他资源，如CSS文件、JavaScript文件、图像等。这些资源可能需要额外的HTTP请求。
8. **显示页面**：
   - 一旦页面的所有资源都被加载和渲染，浏览器会显示完整的页面内容，供用户查看和交互。



1. 如果是 https，则还有一步 tls 握手的过程。
2. tls 握手，确认证书，协商加密协议。



####	22.当用户访问一个web站点时，会经过什么处理才能把页面渲染出来？

1. **DNS解析**:
   - 用户在浏览器中输入网站的URL（统一资源定位符），浏览器首先需要将URL中的主机名解析为对应的IP地址。这通常通过DNS（域名系统）服务器完成。
2. **建立TCP连接**:
   - 一旦浏览器知道了服务器的IP地址，它会尝试与服务器建立TCP连接。这通常需要经过三次握手的过程来确保连接的稳定性。
3. **发起HTTP请求**:
   - 一旦建立了TCP连接，浏览器会向服务器发送HTTP请求。HTTP请求包括请求的类型（GET、POST等）、请求的资源路径、以及其他相关信息，如请求头。
4. **服务器处理请求**:
   - 服务器接收到HTTP请求后，会根据请求的内容和路径执行相应的操作。这可能涉及到从数据库中检索数据、生成动态内容、或者直接提供静态文件。
5. **构建HTTP响应**:
   - 服务器会生成HTTP响应，包括状态码（200表示成功、404表示未找到等）、响应头（如内容类型、Cookie等）和响应正文。
6. **传输HTTP响应**:
   - 服务器将构建的HTTP响应发送回到浏览器，经过已建立的TCP连接传输。
7. **浏览器渲染**:
   - 浏览器接收到HTTP响应后，会对HTML内容进行解析。它会请求其他嵌套资源，如CSS、JavaScript、图像等，以完整渲染页面。这些资源可能需要额外的HTTP请求。
8. **执行JavaScript**:
   - 如果页面包含JavaScript，浏览器会执行JavaScript代码，以实现交互、动画和其他动态功能。
9. **页面渲染**:
   - 浏览器使用HTML和CSS渲染页面，将页面内容显示在用户的屏幕上。这包括排版文本、布局元素、应用样式和渲染图像。
10. **用户交互**:
    - 用户可以与页面进行交互，如点击链接、填写表单、滚动页面等。这将触发浏览器的事件处理程序执行。
11. **关闭连接**:
    - 一旦页面完全加载并显示，或者用户关闭浏览器标签，浏览器将关闭TCP连接。



####	23.讲讲科学上网的原理（G.F.W如何探测，用户端如何绕过）



####	24.如果你部署的服务，有用户反馈感知到很慢，怎么排查问题

（用户端问题：网速，dns，硬件，服务端问题：程序内部，服务器配置问题，硬件问题，dns或者cdn问题）

1. **确认问题**：首先，确认问题是否真的存在，了解用户的具体反馈。确定哪些方面的服务被认为很慢，例如网页加载时间、API响应时间、数据传输速度等。
2. **性能监控**：检查服务器资源的利用率，如CPU、内存、磁盘。
3. **日志分析**：检查应用程序和服务器的日志，查看是否有错误、警告或异常情况。
4. **网络延迟**：检查网络延迟，使用`ping`、`traceroute`或其他网络诊断工具来查看是否有网络连接问题。
5. **CDN和缓存**：如果使用CDN或缓存服务，确保它们正在按预期工作。有时，问题可能是缓存不命中引起的。
6. **负载均衡**：如果使用负载均衡器，确保它正常工作，不会导致某些服务器负载过重。
7. **容器和虚拟化**：如果服务在容器或虚拟机中运行，确保这些环境没有性能问题。
8. **升级和优化**：
9. **第三方服务**：



####	25.手撕伪代码：模拟象棋的“馬”走到目标位置的最近路线，伪代码即可（面试官说主要看思路和代码风格）



1.bfs求最短路

```c++
int solve(vector<vector<int>> map, pair<int,int> start, end){
    queue<pair<int,int>> q;
    q.push(start);
    while(!q.empty()){
        [x,y] = q.front();
        int nx = nxt(x), ny = nxt(y);
        if(nx and ny not outer){
            q.push({nx,ny});
            
        }
    }
}
```







####	26.容器和虚拟机的区别，docker的构成组件有哪些，启动一个容器的时候调用过程是什么样

虚拟机虚拟整个机器，容器仅仅虚拟环境。

docker的构成组件有：

1. docker images
2. docker network
3. docker compose
4. 



####	27.Linux命令：动态查看日志，查看负载，查找某个日期范围的文件，查找以**结尾的行，查看某个进程占用的文件描述符



**1.动态查看日志**

**dmesg命令：**

```bash
sudo dmesg -w 			# 实时查看内核日志

sudo dmesg --level err	 # 查看内核错误信息

sudo dmesg -T			# 显示带有时间戳的内核消息

sudo dmesg -H			# 以人类可读的形式显示内核消息
```

**journalctl命令：**

```bash
# 查看所有系统日志
journalctl

# 查看特定单元（服务）的日志
journalctl -u unitname

# 实时查看系统日志
journalctl -f, --follow
```

journalctl 查看的是systemd日志，由systemd管理的服务和进程生成的日志。

dmesg 查看的是Linux 内核生成的日志，记录了内核操作和硬件事件，包括系统启动，硬件错误，设备驱动程序消息，系统调用等信息。

**传统命令：**

```bash
# 实时动态查看指定文件的末尾内容，可以在文件更新时自动显示新内容。适用于查看日志文件。
tail -f /var/log/syslog

# 类似于 tail -f，但你可以使用 Ctrl+C 来退出实时查看模式。
less +F /var/log/syslog
```



**2.查看负载**

可以通过以下方式，获得 load average

```bash
$ uptime
18:40:03 up  8:37,  1 user,  load average: 0.42 0.70 1.13
    
$ top
top - 18:40:03 up  8:37,  1 user,  load average: 0.42 0.70 1.13
    
$ cat /proc/loadavg 
0.42 0.70 1.13 2/1224 67252
```

load average 后面的三个数字分别表示系统在过去1分钟，5分钟和15分钟内的平均负载

**load average : 给定时间段内正在使用或等待CPU运算的进程数量**

对于load average 数据的解释是：

对于受CPU 限制的单 CPU 系统，可以将平均负载视为相应时间段内系统利用率的一种度量。对于具有多个 CPU 的系统，**必须将负载除以处理器数量才能获得可比较的测量值**。

例如，可以将单 CPU 系统上的负载平均值 **“1.73  0.60  7.98”** 解释为：

- 最后一分钟，系统平均过载73%（1.73个可运行进程，因此单CPU系统平均有0.73个进程等待轮转）。
- 在最后 5 分钟内，CPU 平均有 40% 的时间处于空闲状态。
- 在最后 15 分钟内，系统平均过载 698%（7.98 个可运行进程，因此单个 CPU 系统平均有 6.98 个进程需要等待）。

这意味着这个系统（CPU、磁盘、内存等）如果速度提高 1.73 倍，就可以处理最后一分钟安排的所有工作。

在具有四个 CPU 的系统中，平均负载为 3.73 表示平均有 3.73 个进程可供运行，并且每个进程都可以调度到一个 CPU 中。



**3.查看某个日期范围的文件**

**使用find命令：**

**-newer 和 -newerXY：**

```bash
# 查找修改时间比参考文件更新的文件
find . -newer reference_file
```

-newerXY :

如果文件的时间戳X比文件应引用的时间戳Y新，则成功。

其中X和Y可以是以下任意字母：

- a：access time
- B：birth time
- c：change time
- m：modification time
- t：directly time

```bash
# 查找访问时间比参考文件更新的文件
find . -neweraa reference_file

# 直接引用时间戳, 查找访问时间新于指定时间戳的文件
find . -newerat "2023-10-18 12:00:00" -not -newerat "2023-10-30 12:00:00"
```

**-atime，-ctime 和 -mtime**

- -atime：查找文件的访问时间
- -ctime：查找文件属性（如权限）的修改时间
- -mtime：查找文件的修改时间

```bash
# n代表天数
find . -atime n
# +n 代表查找n天前被访问的文件
# -n 代表查找n天内被访问的文件
```



**4.查看某个进程占用的文件描述符**

**使用lsof命令**

```bash
lsof -p <PID>

lsof -p $(pgrep process_name)
```

lsof输出了很多字段，其中FD是文件描述符：

- cwd：当前工作目录
- txt：文本文件
- mem：内存映射文件
- 0u，1u，2u：打开的标准输入，标准输出和标准错误输出



####	28.RAID 0，1，5区别

- **RAID 0：**
  - 级别名称：条带化
  - 数据分布：数据被分割成块，并分布在多个磁盘上
  - 性能：提供卓越的性能，因为数据可以并行读取和写入
  - 冗余：没有冗余，一快磁盘出现故障，会导致数据完全丢失
  - 最少磁盘数：2块或更多
  - 应用场景：适合需要高性能但不需要数据冗余的情况，如临时数据存储。
- **RAID 1：**
  - 级别名称：镜像
  - 数据分布：每个数据块都又一个镜像副本在另一块磁盘上
  - 性能：读性能通常好，因为可以从多个磁盘读取数据，写性能与RAID 0相比较差
  - 冗余：提供极高的数据冗余。如果一块磁盘损坏，数据仍然可以从另一款磁盘恢复
  - 最少磁盘数：2块或更多，必须成对出现
  - 应用场景：适合需要高度数据冗余和保护的情况，如关键业务数据。
- **RAID 5：**
  - 级别名称：条带化带奇偶校验
  - 数据分布：数据被分割成块，并分布在多个磁盘上，同时每个条带上有一个奇偶校验块
  - 性能：提供不错的性能，尤其对读取操作。写入性能相对较低
  - 冗余：提供适度的数据冗余，如果一块磁盘故障，可以使用奇偶校验数据从其余磁盘中恢复数据
  - 最少磁盘数：3块或更多
  - 应用场景：适合中等性能和数据冗余需求的情况，如文件服务器和小型企业服务器。
- **RAID 6：**
  - 级别名称：双奇偶校验
  - 数据分布：与RAID 5 类似，数据被分割成块，并分布在多个磁盘上，但有两个奇偶校验块。
  - 性能：提供良好的读性能，相对较高的写性能。性能与RAID 5 相比较接近。
  - 冗余：提供高度的数据冗余。可以同时容忍两块磁盘的故障，因为有两个奇偶校验块用于数据恢复。
  - 最少磁盘数：通常需要至少4块磁盘。
  - 应用场景：适合需要高度数据冗余和较好性能的情况，如企业级存储。
- **RAID 10：**
  - 级别名称：条带镜像
  - 数据分布：数据被分割成块，并分布在多个磁盘上，同时每个数据块都有一个镜像副本在另一块磁盘上。
  - 性能：提供非常出色的性能，尤其对于读操作。写入性能也很好，因为数据可以并行写入多个磁盘。
  - 冗余：提供高度的数据冗余。RAID 10 可以容忍一个或多个磁盘的故障，因为数据总是有镜像备份。
  - 最少磁盘数：通常需要至少4块磁盘。RAID 10 的磁盘需求相对高，因为每个数据块都需要镜像。
  - 应用场景：适合需要高性能和高度数据冗余的情况，如数据库服务器和虚拟化服务器。



####	29.iptable了解吗，如何用iptable进行端口转发，ebpf简介



本地端口转发：

假设有一台Linux服务器，想将本地端口80的流量转发到本地端口8080，可以使用以下命令：

```bash
sudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080
```



远程端口转发：

假设你想将来自外部网络的流量转发到内部服务器的某个端口。使用以下命令来实现：

```bash
sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 内部服务器ip:端口号
```



在 iptables 中，`DNAT`（目标网络地址转换）和 `REDIRECT`（重定向）都是用于修改数据包的目标地址或端口的规则，但有一些关键的区别：

**DNAT (Destination NAT)**:

- **用途**: 将数据包的目标地址修改为新的地址。常见用途是将外部请求重定向到内部服务器。
- **适用场景**: 通常用于端口映射，将外部 IP 地址和端口映射到内部的服务器上。

**REDIRECT**:

- **用途**: 将数据包的目标端口修改为本地端口，通常用于将流量重定向到同一台机器上的另一个端口。
- **适用场景**: 常用于本地服务的端口重定向，例如将 HTTP 流量重定向到代理服务器。





####	28.TCP握手挥手，seq如何生成，DNS解析过程，同一个域名对应多个IP或者域名是为什么（CNAME），http状态码



- **seq如何生成：**

  `seq`是一个32位字段，用于标识TCP报文段的顺序。TCP连接的初始序列号是**随机生成**的，通常是一个伪随机数。这是为了增加安全性。随着数据的传输，seq的值逐渐递增，每发送一个TCP报文段，`seq`字段的值会增加报文段所携带的数据字节数。

- **DNS解析过程**

  - 如果是windows主机，先检查hosts文件，如果没有对应字段
  - 向本地DNS服务器查询（通常由运行商提供），如果本地缓存没有
  - 则将向根域名服务器发起查询，它会返回对顶级域名服务器的地址
  - 本地DNS服务器向顶级域名服务器发起查询，得到权威域名服务器的一级DNS服务地址，该DNS服务器通常由注册域名提供商提供的。
  - 本地DNS服务器向权威域名服务器查询，权威域名服务器将返回域名的IP地址。本地解析器将其缓存下来并返回给查询主机

  以上是迭代查询，也可以是递归查询

  

- **同一个域名对应多个IP或者域名是为什么**

  一个域名对应多个IP或域名主要是为了：

  - 负载均衡
  - 冗余和故障转移
  - 内容分发网络（CDN）

  可以通过DNS和增加设备实现

  DNS可以添加A或AAAA或CNAME记录

  

- **HTTP状态码**

  

  - 200 ：请求成功
  - 301 ：请求的对象已经被永久转移了
  - 400：该请求不能被服务器理解
  - 401：需要授权
  - 403：拒绝
  - 404：被请求的文档不在服务器上
  - 505：服务器不支持请求报文使用的HTTP协议版本



####	29.http和https的区别



1. 安全性：
   - HTTP：HTTP是明文协议，数据在传输过程中以纯文本形式传输，这意味着敏感数据可以在传输过程中被窃取，HTTP不提供数据加密或身份验证，因此不安全
   - HTTPS：HTTPS是HTTP的安全版本，它通过使用TLS/SSL协议对数据进行加密和身份验证，从而提供了更高的安全性。使用公钥和私钥对数据进行**非对称加密**和解密，确保只有服务器能够解密数据
2. 端口：
   - HTTP：HTTP默认使用端口80进行通信
   - HTTPS：HTTPS默认使用端口443进行通信



关于HTTPS的一些谬论

当HTTPS最初开始推广时，实施确实困难，缓慢，并且代价昂贵。这些障碍如今不复存在。

1. **我的网站不处理敏感信息，所以不需要HTTPS**

   网站不实施安全性的一个常见原因是，他们认为这样做是大材小用。毕竟，如果不涉及敏感数据，有谁会在乎有没有人窥探？出于某些原因，这是将 Web 安全性过于简单化的看法。

   例如，**某些 Internet 服务提供商实际上会将广告注入到由 HTTP 服务的网站中**。这些广告或许与网站内容相称，或许不符，并有可能令人反感，不仅仅是网站提供商没有创造性的投入或收益分成。一旦站点设有安全保护，这些注入的广告将不再可行。

   如今，**现代 Web 浏览器（chrome）限制了不安全站点的功能**。提高网站质量的重要功能需要 HTTPS。地理位置、推送通知和运行渐进式 Web 应用程序（PWA）所需的服务工作器都需要更高的安全性。这很有道理；用户位置等数据属于敏感数据，可被用于恶意目的。

2. **我不想增加页面加载时间，让网站的性能受损**

   性能是用户体验以及 Google 如何返回搜索结果的重要因素。可以理解，增加[延迟](https://www.cloudflare.com/learning/performance/glossary/what-is-latency/)值得认真考虑。幸运的是，随着时间推移 HTTPS 已有改进，降低了建立加密连接所需的性能开销。

   ![TCP 握手](https://www.cloudflare.com/img/learning/cdn/tls-ssl/tls-ssl-handshake.png)

3. **实施 HTTPS 对我而言代价太高**

   在某一点上或许正确，但现在成本不再是问题；Cloudflare 让网站能够免费获得加密传输。我们是第一家免费提供 SSL 的公司，并且也会继续下去。通过提高整个互联网的安全性，我们能够使互联网变得更加安全、更加快速。





####	30.负载均衡，常见的负载均衡怎么实现，硬件负载均衡和软件负载均衡的区别，作用

可以进行硬件负载均衡和软件负载均衡

1. 硬件负载均衡：

   部署专用的硬件设备（如深信服应用交付AD），实现负载均衡

2. 软件负载均衡：

   使用反向代理服务器，如 Nginx，来实现负载均衡。在容器环境中，也可以使用K8S来编排容器，实现负载均衡。

硬件负载均衡，提供更高的性能的，更昂贵，部署和管理相对较简单，通常有图形化界面

软件负载均衡，运行在服务器或虚拟机上，可以部署在现有基础设施上，灵活性更高，成本更低，但是部署和配置起来可能麻烦一些



软件实现： LVS RAC MySQLProxy Nginx HaProxy
硬件实现： F5 citrix array 深信服 梭子鱼



####	CPU的虚拟化，作用是什么，为什么采用CPU虚拟化

作用是可以有多个进程同时运行。

采用CPU虚拟化，使得每个进程认为自己都在独占CPU，但实际上它们共享物理CPU。

采用陷阱机制，中断机制和受限直接运行和操作系统的调度机制，使得它们安全且高效的交替执行。



####	31.linux发行版本有哪些，主要使用的哪些

**Linux发行版本有：**

Ubuntu，Debian，CentOS，RHEL，Arch，Kali

**主要有使用：**

Ubuntu 22.04.1 LTS

Linux Mint 21



####	32.linux基础命令：cp，cat，scp，ssh，mv......

**远程连接命令：**

- ssh：非对称加密连接

**权限更改命令:**

- chmod：更改当前文件的权限
- umask：更改默认权限

**进程相关命令：**

- pgrep：根据进程名称得到进程ID

- pkill：根据进程名称发送信号

- pidstat：显示进程所使用的资源，包括cpu，内存，IO

  ```bash
  pidstat -r -u -p $(pgrep netdata)
  ```

- jobs：查看后台执行的进程

- fg，bg：将进程移至前台或后台

  ```bash
  $ jobs
  [1]+ Running xlogo &
  $ fg %1
  xlogo
  ```

- kill：根据进程号发送信号：

  ```bash
  kill [-signal] PID...
  ```

- Ctrl-c，Ctrl-z：终止或停止进程

- &：将进程放置后台执行

  ```bash
  $ xlogo &
  ```

- lsof：查看某个进程打开的文件描述符

  ```bash
  lsof -p $(pgrep netdata)
  ```

**网络相关命令：**

- ping：连通性检测

- traceroute：路由检测

- netstat：显示打开的连接，套接字端口等

  ```bash
  netstat -tnlu
  ```

- nslookup：查找DNS的各种记录（Rource Record：四元组（name,value,type,ttl））

  ```bash
  # 默认查找A记录
  nslookup example.com
  
  # 向8.8.8.8 DNS服务器查找guoxiang.fun的NS记录
  nslookup -type=NS guoxiang.fun 8.8.8.8
  
  # 反向查找
  nslookup -type=PTR 8.8.8.8
  
  ```

- curl cip.cc：查找公网地址的运行商信息，位置

  ```bash
  curl cip.cc	# 查看本机公网地址信息
  
  curl cip.cc/8.8.8.8	# 查看指定公网地址的信息
  ```

  

- route：查看和配置路由表

- dig：查看DNS记录

- ss：显示系统套接字信息

- nc：在网络上发送和接收数据

**查找命令：**

- find：
- locate：
- grep：

**文本处理命令：**

- sed
- awk



####	33.UEFI和BIOS的区别，作用



**1.UEFI和BIOS：**

**UEFI：**统一可扩展固件接口，是一种系统规格，用来定义操作系统和系统固件之间的软件界面，作为BIOS的替代方案。类似于一个低阶的操作系统，具有操控所有硬件资源的能力，好像是使用C语言编写的，比传统BIOS更容易实现，容错纠错能力更强

**BIOS：**基本输入输出系统，在通电阶段执行硬件初始化，为操作系统在运行是提供服务的固件。通常在主板的ROM上，通常是由汇编语言编写的

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/49/Efi-simple_zh-cn.svg/1920px-Efi-simple_zh-cn.svg.png" alt="undefined" style="zoom: 25%;" />



**2.UEFI中的CSM，LegacyMode：**

现在的个人电脑几乎使用的都是UEFI，但仍然习惯的称为BIOS。UEFI可以模拟BIOS启动。

![img](https://miro.medium.com/v2/resize:fit:573/0*PJ6w7r0dJhPFkxtG.JPG)

如果主板有不支持UEFI的设备，可以开启**CSM（Compatibility Support Module相容性支持模组）**，它是UEFI淘汰BIOS中的过渡功能，模拟传统BIOS启动，也称为LegacyMode，Legacy BIOS等。关闭CSM则无法使用传统BIOS启动



**3.UEFI中的Secure Boot：**

**Secure Boot （安全启动）**：利用数字签名来确认EFI驱动程序是否是受信任的

安全启动设计之初作用是防止恶意软件入侵。事实上它能够做到的，当电脑器被病毒启动后，它会发出提醒并拒绝启动，避免可能带来的进一步损失。更多的人认为，这是微软为了阻止安装Windows操作系统的电脑改装Linux。客观的讲，微软设计Secure Boot的确切用意可能是为了保证系统安全，但结果似乎变成了PC厂商保护市场的垄断、阻止竞争的一种手段。**现在它是可以被打开/关闭的**。

**Secure Boot要求严格UEFI环境，即无法开启CSM**，那么开启Secure Boot的系统不支持Legacy启动及Legacy Option ROM。



**4.UEFI的GPT，BIOS的MBR：**

**GPT，全局唯一标识分区表，GUID Partition Table，**缩写GPT，是使用GUID对物理计算机存储设备的分区表进行布局的标准。好像UEFI只能按照在GPT模式的硬盘上。GPT支持巨大的硬盘容量，**可以分割成128个分区**。



**MBR，主引导记录，Master Boot Record，**缩写MBR，只支持**最大为2TB**的硬盘容量，**且每个磁盘最多只能有4个分区（3个主分区，1个扩展分区）**，通常于传统的BIOS一起使用。



GPT的灵活性和容量支持更多的分区，因此更适合现代计算设备。



####	34.liunx里如何查看cpu利用率和cpu？

1. **mpstat命令：**查看CPU使用情况，包含每个CPU的使用率。

   ```bash
   $ mpstat
   Linux 5.15.0-58-generic (gx-bash)       10/19/2023      _x86_64_        (2 CPU)
   
   10:35:33 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
   10:35:33 PM  all    1.46    0.16    0.29    0.01    0.00    0.00    0.00    0.00    0.00   98.07
   ```

2. **lscpu命令：**用于显示 CPU 信息，包括 CPU 类型、架构、核心数等。

3. **cat /proc/cpuinfo：**本质上，都是读取/proc中的文件信息。proc是进程信息和系统信息的伪文件系统，提供了内核数据结构的接口。通常挂载在/proc处，通常它由系统自动挂载。大多数我呢见都是只读的。

**记住，只要是系统性能数据，进程使用率等信息，都可以通过读取/proc中的文件来完成。**





####	35.**liunx容量满了要怎么办（我不记得说的是磁盘满了还是内存满了，应该是磁盘满了**

1. **查看磁盘使用情况：**首先需要知道是哪个文件系统占用了大部分磁盘空间

   - lsblk -l
   - du -h --max-depth=1 /home/gx
   - 

2. **清理文件：**删除不必要的文件，可以使用 rmdir 删除空目录

3. **检查临时文件：**某些应用程序可能会在 /tmp 目录中创建大量临时文件，可以定期清理这些文件

4. **压缩大文件：**可以使用tar 和zip来压缩它们。

5. **移动数据：**将数据移至有空余容量的分区

6. **清理软件包缓存：**Linux可能会保存软件包的缓存，可以使用包管理工具apt，yum来清理这些缓存

7. **增加硬盘并拓展分区：**

   1. **安装新硬盘：**

      ![img](https://img-blog.csdnimg.cn/e9b3bea8087d4990b52064258ee7d8ef.png)

   2. **分区和格式化：**可以使用fdisk来创建分区，mkfs来格式化分区：

      ```bash
      # 启动分区操作器,选择该硬盘；将进入 fdisk 命令交互界面
      sudo fdisk /dev/sdb	
      
      # 格式化新分区
      sudo mkfs.ext4 /dev/sdb1
      ```

   3. **挂载新分区**：创建一个目标文件夹，然后将新分区挂载到这个目标文件夹。这将使你能够访问新硬盘的存储空间。

      ```bash
      # 创建一个目标文件夹
      mkdir /mnt/new_drive  
      
      # 挂载新的分区
      mount /dev/sdb1 /mnt/new_drive
      
      # 查看文件系统挂载在哪里
      mount | grep '/dev/sdXN'
      ```

   4. **自动挂载**：如果你希望在系统重新启动后仍然自动挂载新硬盘，可以将分区信息添加到 **`/etc/fstab`** 文件中。编辑 `/etc/fstab` 并添加一行，如下所示：

      ```bash
      /dev/sdb1   /mnt/new_drive   ext4   defaults   0 0
      ```

      这会在启动时自动挂载新硬盘。确保文件系统类型和挂载选项适合你的需求。

   5. **迁移数据**：你可以将现有数据复制到新硬盘上，以释放旧硬盘的空间。使用 `rsync` 或 `cp` 命令来实现。

      ```bash
      sudo rsync -avx /source_folder /mut/new_drive
      ```

      `rsync`（remote synchronization）是一个用于在本地和远程系统之间同步文件和目录的实用工具。它是一个功能强大的工具，通常用于备份、远程复制文件、镜像文件夹，或在不同计算机之间同步文件。`rsync` 使用了一个高效的算法，可以快速传输只发生变化的文件部分，从而减少数据传输量和节省带宽。



fdisk 不支持 GPT 格式。可以使用 parted，它支持 MBR 和 GPT 分区。

1. 启动 parting

   ```bash
   sudo parted
   ```

2. 选择设备

   ```bash
   select /dev/sdb2
   ```

3. 



####	36.TCP/IP模型，每一层有什么作用，应用层采用的协议有哪些

OSI七层：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层

TCP/IP四层：应用层，传输层，网络层，网络接口层

应用层有：DNS，SMTP，HTTP，P2P，SSH，TELENT，FTP，RPC

网络层有：IP（v4.v6)，ICMP，BGP，RIP，OSPF

数据链路层有：ARP，STP，802.1aq





####	37.DNS服务器原理

1. **域名解析请求：**www.guoxiang.fun
2. **本地域名解析器查询：**如果没有缓存则往下
3. **根域名服务器查询：**查询.fun的顶级域名服务器的地址
4. **顶级域名服务器查询：**查询guoxiang.fun权威域名服务器的地址
5. **权威域名服务器查询：**返回www.guoxiang.fun给本地域名服务器
6. **本地DNS服务器缓存**：本地DNS服务器会将这个IP地址存储在缓存中，以备将来使用。然后，它将IP地址返回给浏览器，以便浏览器可以建立到该IP地址的连接并加载网页。



####	38.在服务器中如何查看网络流量

1. 使用命令行工具：iftop，nload
2. 使用监控工具：Zabbix，普罗米修斯
3. iperf



####	39.linux的文件系统有哪些

1. **ext4：**Extended File System 4是Linux最常用的文件系统之一。它支持大容量的文件和分区，提供了日志记录和高性能。
2. **XFS：**XFS是一种高性能的日志文件系统，特别适用于大型文件和分区。它支持高度并发的读写操作。
3. **btrfs：**Btrfs（B-tree File System）是一种先进的文件系统，具有数据校验、快照、压缩和各种高级功能。
4. **ZFS：**ZFS是一种先进的文件系统，最初由Sun Microsystems开发。它支持高级的数据管理、快照、数据完整性检查和自愈能力。





####	40.linux中如何做定时任务，里面是怎么配置的

crontab：创建，编辑和管理用户的定时任务的命令

```bash
# 编辑用户的crontab文件
crontab -e

# 列出用户当前的crontab内容
crontab -l

# 删除用户的crontab文件
crontab -r
```





![img](https://pics7.baidu.com/feed/f3d3572c11dfa9ecbee474e9667d2d0f938fc1bb.jpeg@f_auto?token=ae211dcf9ebd6b71d4fe60f5ae64098e)



####	41.如何做服务器的安全加固

**操作系统更新**：

- 示例：使用`yum`或`apt-get`定期更新操作系统，如CentOS或Ubuntu。
- 示例：创建一个自动化的任务，每周自动检查并安装操作系统安全更新。

**防火墙配置**：

- 示例：使用`iptables`或`firewalld`配置防火墙规则，只允许HTTP（端口80）和HTTPS（端口443）流量进入服务器。
- 示例：拒绝所有不明来源的SSH访问。

**账户和访问控制**：

- 示例：删除不需要的用户账户。
- 示例：限制`sudo`权限，只有授权用户才能以超级用户权限运行命令。

**加密通信**：

- 示例：配置Apache或Nginx以使用TLS/SSL来加密HTTP通信。
- 示例：使用Let's Encrypt来获得免费SSL证书。

**安全备份**：

- 示例：创建定期备份计划，将备份数据存储在离线或云端位置。
- 示例：测试备份的可恢复性。

**应用程序安全**：

- 示例：对Web应用程序进行漏洞扫描，修复已知的漏洞。
- 示例：禁用或限制不需要的服务和组件。

**文件完整性检查**：

- 示例：使用工具如`AIDE`创建文件完整性数据库，以监视系统文件的更改。
- 示例：定期运行完整性检查，比较文件哈希值。

**安全培训**：

- 示例：为员工提供有关社会工程、弱密码和恶意电子邮件的安全培训。
- 示例：教育员工如何识别潜在的网络威胁。

**网络安全**：

- 示例：使用网络入侵检测系统（NIDS）来监测网络上的异常活动。
- 示例：配置入口规则，拒绝来自不受信任IP地址的访问。



####	42.redis的作用，做什么的


Redis（Remote Dictionary Server）是一个开源的内存数据存储系统，它被广泛用作缓存、消息代理、任务队列以及分布式数据存储。它具有以下作用和特点：

1. **缓存：** Redis通常被用作缓存层，用来存储经常访问的数据，以减轻后端数据库的负载。因为Redis是基于内存的，所以读取速度非常快。
2. **键值存储：** Redis是一个键值数据库，你可以存储各种类型的数据（字符串、哈希、列表、集合、有序集合等）。这让它非常灵活，可以用来存储各种数据。
3. **消息代理：** Redis支持发布/订阅模型，允许不同组件或服务之间进行异步通信。这在构建实时系统和队列处理中非常有用。
4. **任务队列：** Redis可以用来创建轻量级任务队列，例如用于处理后台任务、作业调度等。
5. **分布式数据存储：** Redis支持主从复制、分片等功能，可以用来构建分布式系统，提高数据可用性和扩展性。
6. **计数器和统计数据：** Redis非常适合用于跟踪计数、记录统计数据等应用。
7. **地理空间索引：** Redis的新版本支持地理空间数据的索引，允许你存储和查询地理位置相关的数据。

总之，Redis是一个多功能的数据存储系统，它以高性能、低延迟为特点，可以应用在各种领域，特别是那些需要快速读写操作、高并发和实时性的应用中。





####	43.linux中如何搭建java环境

**安装Java：** 安装所选Java版本。以下是一些常见Linux发行版的安装示例：

- **Ubuntu/Debian：**

  ```bash
  sudo apt update
  sudo apt install default-jre   # 安装JRE（Java Runtime Environment）
  sudo apt install default-jdk   # 安装JDK（Java Development Kit）
  ```

- **CentOS/RHEL：**

  ```bash
  sudo yum install java-11-openjdk   # 安装OpenJDK 11，可根据需要选择其他版本
  ```

**配置Java环境变量（可选）：** 为了方便使用Java，你可以设置JAVA_HOME和PATH环境变量。编辑`~/.bashrc`或`~/.zshrc`文件，添加以下行：

```bash
export JAVA_HOME=/usr/lib/jvm/default-java  # 指定Java安装目录
export PATH=$PATH:$JAVA_HOME/bin
# 或 export PATH="$JAVA_HOME/bin:$PATH"
```

或使用 sed

```bash
sed -i 'a\export JAVA_HOME=/usr/lib/jvm/default-java\' /etc/profile
sed -i 'a\export PATH=$PATH:$JAVA_HOME/bin\' /etc/profile
```

然后使用以下命令加载环境变量：

```bash
source ~/.bashrc  # 如果使用Bash
```

**验证安装：** 重新运行 `java -version` 命令以确保Java正确安装。





####	44.IP是什么，子网掩码做什么的

IP地址标识网络中的实体，有IPv4和IPv6两个版本，IPv4是一组32位二进制，而IPv6为128位。

IP地址逻辑上由网络地址和主机地址构成，而子网掩码用来区分网络地址和主机地址。





####	45.如何将一个进程后台运行，并且在退出后能不断开进程的方式

**使用nohup命令:**

nohup - 运行不受挂起影响的命令，并将输出输出到非 tty

```bash
nohup your_command &
```

命令在终端退出后继续运行，且标准输出和错误输出被重定向到文件 `nohup.out`

**使用tmux工具：**

```bash

```



####	46.开始抓shell脚本：
 **1、监控指定的进程运行状态，如果进程掉了再重启**

```bash
#!/bin/bash

# 定义要监控的进程名
process_name='open_fd.sh'

while true; do
    # 使用pgrep命令检查进程是否存在 -x --exact 精确匹配
    if ! pgrep -x "$process_name" &> /dev/null; then
        echo "[$(date)] 进程 $process_name 不存在，正在重新启动..."
        nohup ~/school/open_fd.sh &
        # 在这里添加启动进程的命令
        # 例如，如果你的进程是一个可执行文件，可以使用：
        # /path/to/your_program &
        # 如果是脚本，使用：
        # /path/to/your_script.sh &
    fi

    # 休眠一段时间后再次检查
    sleep 10  # 休眠10秒，你可以根据需要调整
done
```



**2、实现计算并输出**

```bash
#!/bin/bash
# 计算阶乘
n=$1
res=1
for(( i=n; i>0; --i)); do
    res=$[ res*i ]
done
echo "result = $res"
```



**3、监控文件的变化情况，并及时告知管理员邮件**

通过自定义输出stat格式，来判断文件是否被更改。

```bash
#!/bin/bash

# 配置你要监控的文件路径
file_to_monitor="/home/gx/school/foo"

# 初始化文件的初始时间戳
previous_timestamp=$(stat -c %Y "$file_to_monitor")

while true; do
    # 获取文件的当前时间戳
    current_timestamp=$(stat -c %Y "$file_to_monitor")
    
    # 检查文件是否被修改
    if [ "$current_timestamp" -gt "$previous_timestamp" ]; then
        # 当文件发生修改时发送邮件通知管理员
        subject="File Change Detected: $file_to_monitor"
        message="The file $file_to_monitor has been modified."
        # 已事先通过ssmtp配置smtp服务器,账号,密码等
        echo "$message" | mail -s "$subject" guoxiang.sz@qq.com 
        
        # 更新时间戳
        previous_timestamp="$current_timestamp"
    fi
    
    # 每隔一段时间检查文件变化（例如，每30秒）
    sleep 30
done

```







####	47.对shell脚本怎么执行

**1.直接执行脚本文件：**

```bash
chmod u+x my_script.sh
./my_script.sh
```

**2.通过shell解释器执行：**

​	没有为脚本添加执行权限，可以使用shell解释器来运行脚本

```bash
bash my_script.sh
```

**3.使用source执行：**

​	使用`source`命令在当前Shell环境中执行脚本，这通常会影响到当前环境变量

```bash
source my_script.sh
```

​	脚本中对环境变量的更改将在当前shell中生效，定义函数和别名也将在当前shell中可用



####	48.向Linux主机传输文件 

只使用过scp：

```bash
scp source_path destination_path
```



####	49.你对cdn了解多少

CDN：Content Distribution Network，内容分发网络。CDN服务商在因特网上安装了许多地理上分散的web缓存器，使大量流量实现了本地化，减少用户请求的响应时间和降低原始服务器的负载。

**CDN工作原理：**

1. **内容缓存：** CDN服务器缓存网站和应用程序的静态和动态内容，如图像、CSS、JavaScript、视频等。
2. **请求重定向：** 当用户请求某个内容时，CDN的DNS服务器会将用户的请求路由到离用户更近的CDN服务器，而不是源服务器。
3. **内容传输：** CDN服务器提供请求的内容，然后将其传送到用户，以确保较低的延迟和更快的加载速度。
4. **缓存更新：** CDN服务器会定期与源服务器同步以获取最新的内容。如果内容在源服务器上更新，CDN会在一定时间内更新缓存，以便提供最新的内容。

**特点：**

1. **高性能：** CDN的服务器分布在全球各地，可将内容从最近的服务器提供给用户，提高了网站性能，降低了加载时间。
2. **高可用性：** CDN提供冗余和负载均衡，确保即使在服务器故障的情况下，用户仍然能够访问内容。
3. **安全性：** CDN提供安全性能，包括DDoS攻击防护和Web应用程序防火墙，以保护网站和应用程序免受威胁。
4. **减少服务器负载：** CDN可以减少源服务器的负载，因为它承担了大部分的用户请求，从而增加了服务器的可扩展性。
5. **全球分发：** CDN的服务器分布在全球，可在世界各地快速传送内容，从而提供更好的用户体验。



####	50.是否配置过域名

配置过，我的网站就是。

1. 先在阿里云上购买域名，在阿里云上设置解析该域名的权威服务器地址
2. 使用Cloudflare解析该域名，添加为CNAME记录，指向国外托管网站的域名
3. 使用Cloudflare提供的 FreeSSL 和 CDN 服务，使得可以正常访问





####	51.Session和Cookie的区别

Session和Cookie都用于在Web应用程序中存储和管理用户相关的数据。它们的区别如下：

**1. 存储位置：**

- **Cookie：** Cookie是存储在用户浏览器中的**小文本文件**，通常是**键值对**的形式。它们被保存在用户本地，每次用户请求与相应域名相关的网页时都会随请求一起发送到服务器。
- **Session：** Session数据存储在服务器端，通常在服务器上创建一个唯一的会话标识符，将其与用户相关的数据存储在服务器上。当用户访问Web应用程序时，服务器使用会话标识符来检索相应的数据。

**2. 安全性：**

- **Cookie：** Cookie在客户端存储，因此有一些安全性问题，例如用户可以查看和修改它们。虽然可以通过设置Cookie的HttpOnly和Secure属性来增加安全性，但仍然存在风险。
- **Session：** Session数据存储在服务器上，用户无法直接访问或修改它们，因此通常更安全。但是，会话劫持攻击（Session Hijacking）仍然是一个潜在的威胁，因此需要采取安全措施。

**3. 存储容量：**

- **Cookie：** Cookie通常有较小的存储容量，一般不适合存储大量数据。
- **Session：** 由于数据存储在服务器上，Session通常可以存储更多的数据，因此更适合存储大型数据。

**4. 生命周期：**

- **Cookie：** 可以设置Cookie的过期时间，可以是会话Cookie（在浏览器关闭后过期）或持久Cookie（在指定时间内过期）。
- **Session：** 会话数据通常与用户的会话周期相关联，一般在用户关闭浏览器或注销时过期。

**5. 使用场景：**

- **Cookie：** 适合存储少量不敏感的数据，如用户首选项、购物车内容、用户跟踪等。也用于实现用户认证和跟踪用户行为。
- **Session：** 适合存储较多或敏感的数据，如用户登录状态、用户权限、购物车中的详细信息等。通常用于维护用户的会话状态。



####	52.Linux文件系统?文件格式?

Linux文件系统有：

- **ext4**
- **xfs**
- **btrfs**

Linux文件格式有：

- **- (普通文件)**: 普通文件包含文本、二进制数据或其他内容。它们是最常见的文件类型
- **d (目录)**: 目录是用于组织文件和其他目录的特殊文件类型。它们包含文件和子目录
- **l (符号链接)**: 符号链接是指向其他文件或目录的链接，允许你在文件系统中创建引用
- **c (字符设备)**: 字符设备是用于读写字符数据的设备，如终端或键盘，一般位于/dev
- **b (块设备)**: 块设备是用于读写块数据的设备，如硬盘驱动器，/dev/sda
- **s (套接字)**: 套接字用于进程之间的通信，通常用于网络通信，一般位于/var/run中
- **p (管道)**: 管道用于进程之间的通信，通常用于将一个进程的输出连接到另一个进程的输入





####	53.讲讲知道的Linux命令?查找进程?修改权限?退出vim?

查找进程：

```bash
ps aux | grep process_name

pgrep xxx
pgrep -x	# 严格匹配

pstree

top

pkill

```

修改权限：

```bash
chmod u+x file_name
chmod 766 file_name
```

退出vim

```bash
: + x # 保存并退出
```



####	54.你和朋友通过WIFI互ping发现不通，原因可能是什么?

首先检查我和朋友两台主机的IP地址是否属于同一网段。

如果不属于则可能是WIFI没有开启DHCP或主机设置了静态IP。

如果属于同一网段，且连接的是同一路由器。则可能是路由器故障，或是路由器或者主机禁用了ICMP。



####	55.电脑性能的高低取决于哪些方面?

取决的方面有很多。

硬件方面主要取决于：

- CPU：处理器的时钟速度，核心数量和架构等因素
- 内存：容量大小，频率，时序
- 硬盘：容量大小，读写速率
- 主板：总线速度，接口标准，插槽扩展
- 显卡：GPU数量，显存大小，散热，输出接口
- 电源：额定功率，转换效能
- 散热器：水冷，风冷（热管数量）
- 外设：

软件方面主要取决于：

- 操作系统

- 网络连接

  

####	56.内存条有哪些种类，有什么区别? 每种的频率在多少范围?

目前主要使用DDR-SDRAM（Double Data Rate Synchronous Dynamic Random-Access Memory），最新已经到第五代，每一代都别上一代功耗更低，电压更低，时钟频率更高。

外观上区别如下：

<img src="C:\Users\guoxiang\AppData\Roaming\Typora\typora-user-images\image-20231026154447113.png" alt="image-20231026154447113" style="zoom: 33%;" />

标准：

DDR4 1600 - 3200 时钟频率 800 - 1600MHz

DDR5 4000 - 8000 时钟频率 2000 - 4000MHz 





####	57.CPU和主板的搭配怎样发挥出最佳性能?

个人认为：

- 8+8内存组双通道内存（cpu可以并行访问两条内存）

- 固态硬盘

- 双塔六热管14cm风冷，或华硕恩杰海盗船水冷

- 不低于400W的电源

- UEFI，关闭CSM，Secure Boot，调整内存频率，适当对CPU加压超频

- 64位操作系统，LTSC版本

- aida64进行压力测试

  



####	58.CPU针脚有多少? 睿频怎么样?

INTEL：

- **LGA 1151：**支持 Core i3/i5/i7/i9（6-9代），
- **LGA 1200：**支持Core i3/i5/i7/i9（10-11代），睿频4.7
- **LGA 1700：**支持Core i3/i5/i7/i9（12-14代），睿频5.0+

AMD：

- **AM4 (LGA 1331)：**支持ZEN2，ZEN3（Ryzen 1000,2000,3000,5000,6000）
- **AM5(LGA 1718)：**支持ZEN4（Ryzen 7000）



####	59.某主板最大支持什么型号的CPU?

![img](https://pic2.zhimg.com/v2-9beba11faa5660399280c2c6a1930ae1_b.webp?consumer=ZHI_MENG)



####	60.电脑蓝屏应该怎么处理? 处理过程是怎样的?

1. 先拍照记录，保留错误信息如错误代码
2. 重启，可以以安全模式启动
3. 查看 winevr
4. 根据错误信息或用户提供的信息对症处理



####	61.网络正常连接但是网页打不开是什么问题?如何处理?

初步估计是：

1. 企业有配置上网认证，重定向可能没有触发
2. 用户使用了翻墙软件，没有关闭代理
3. DNS配置错误

处理步骤：

1. nslookup，检查能否解析到地址。若不能则检查DNS配置，更正位正确的地址

2. 检查代理设置，关闭使用环回地址代理

3. 检查本地hosts文件，是否有错误信息

4. 切换浏览器

5. 查看浏览器提示，如访问jd提示证书问题，需要安装系统补丁（WIN7系统根证书没有更新）

6. 检查本地防火墙

7. 恶意软件

8. 检查网站状态，可能是网站本身问题

9. 联系网络运营商

   

####	**62.Linux的$符号作用?**

变量替换，命令替换。



####	63.top指令返回的CPU占用率和什么有关?

和操作系统中运行的进程和线程的CPU使用情况有关





####	 64.Linux系统如何查看当前CPU占用? 内存占用?

CPU占用：

- top
- mpstat

内存占用：

- free -h



####	65.HTTP状态码，问了3xx,301,304,502,504

**1xx（临时响应）**

**2xx （成功）**

**3xx （重定向）**表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

- 301：表示客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。
- 304：客户端有缓冲的文件并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。
- 

**4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。**

- 400  （错误请求） 服务器不理解请求的语法。
- 401  （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403  （禁止） 服务器拒绝请求。
- 404  （未找到） 服务器找不到请求的网页。

**5xx（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。**

- 502  （错误网关）服务器作为网关或代理，从上游服务器收到无效响应。
- 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。

- 505  （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。
- 



####	66.如何配置安装源，如何配置本地源？

1. **创建本地软件包存储库**：

   首先，您需要创建一个本地软件包存储库，该存储库包含您想要安装的软件包。您可以使用 `dpkg-scanpackages` 工具创建本地存储库，或者手动将软件包文件（.deb 文件）放入一个目录中。这个目录将成为您的本地源。

2. **设置本地源路径**：

   您需要确定本地源的路径，即包含软件包的目录的路径。通常，这个路径将是一个本地目录的绝对路径，例如 `/path/to/local/repository`。

3. **创建本地源配置文件**：

   在 `/etc/apt/sources.list.d/` 目录中，您可以创建一个新的 `.list` 文件，该文件包含了您的本地源的信息。这是一个示例 `.list` 文件：

   ```bash
   sudo vim /etc/apt/sources.list.d/local-repo.list
   
   # trusted=yes 表示您信任本地源, file:/ 后面的路径是您的本地源路径
   deb [trusted=yes] file:/<local-source-path> ./
   
   ```

4. **刷新本地源信息**：

   ```bash
   sudo apt update
   ```

5. **安装本地软件包**：

   ```bash
   sudo apt install package-name
   ```

6. 



####	67.要安装一个软件包，有哪些方式安装说说过程

1. 使用包管理器安装：

   ```bash
   sudo apt update
   sudo apt install package_name
   
   # 或使用 snap 包管理工具
   sudo snap install package_name
   ```

2. 源码编译安装

   ```bash
   # git clone xxx.git  下载源码
   
   # 例如使用 make 编译
   sudo make install
   ```

3. 二进制安装

   下载二进制文件，手动解压并安装

4. 

####	68.私网地址有哪些

1. A类：10.0.0.0 - 10.255.255.255
2. B类：172.16.0.0 - 172.31.255.255
3. C类：192.168.0.0 - 192.168.255.255



####	69.如果有100台主机，没有yum源，没有网络，如何修改密码(不使用ansible)

如果有内网，写脚本ssh到每一个主机上批量修改



####	70.说一下防火墙，并且使用命令完成任意来源请求，请求1.1.1.1的80端口的tcp请求全部拒绝



```bash
sudo iptables -A INPUT -p tcp -d 1.1.1.1 --dport 80 -j DROP
```



####	71.如果你的客户的根磁盘满了，怎么解决(不要说扩容)



####	72.日志文件的根据大小去定时清理如何操作

下面这个示例是每个4个小时，定时清理

```bash
dir=/var/log/
maxSize=$(( 2**30 )) # 1 Gbi

while true; do
	for file in "$dir"/*; do
		[[ $(stat --format %s $file) -ge $maxSize ]] && rm -f $(file) && echo "rm $file !"
	done
	sleep $((3600 * 4))
done
```

也可以通过 crontab 定时执行清理



####	73.Linux系统查找管道文件命令

1. 使用 find

   ```bash
   find / -type p 2> /dev/null
   ```



####	74.Linux中较大文件应该使用什么命令查看

1. 使用 find

   ```bash
   find . -size +1G
   ```



####	75.HTTP和HTTPS区别？用了什么加密算法？

HTTP：明文传输



HTTPS（Hypertext Transfer Protocol Secure）使用了一种称为 TLS（Transport Layer Security）的协议进行加密通信。TLS 是 SSL（Secure Sockets Layer）的继任者，目前主要使用的版本是 TLS 1.2 和 TLS 1.3。

TLS 协议使用了多种加密算法来确保通信的安全性，其中包括：

1. **对称加密算法（Symmetric Encryption）：**使用相同的密钥进行加密和解密，这个密钥被称为对称密钥或共享密钥。 用于加密传输过程中的实际数据。常见的对称加密算法有 AES（Advanced Encryption Standard）。
2. **非对称加密算法（Asymmetric Encryption）：** 用于在通信开始时建立安全连接和进行密钥协商。常见的非对称加密算法有 RSA、DSA、ECDSA。
3. **哈希函数（Hash Functions）：** 用于生成数据的哈希值，确保数据完整性。常见的哈希函数有 SHA-256。
4. **数字签名（Digital Signatures）：** 用于验证通信双方的身份和确保消息的真实性。通常结合非对称加密算法使用。

TLS 的发展是为了提供更强大、更安全的加密机制，并修复 SSL 协议的一些漏洞。TLS 1.3 是最新版本，它进一步改进了安全性和性能，去除了一些弱点，并提供更快的握手过程。实际使用的具体加密算法和参数可以通过查看网站的 TLS 证书信息获得。



####	76.dns和https端口多少？

DNS：UDP 53

HTTPS：TCP 443



####	77.Linux 如何过滤包含关键字的文件？

1. 使用 grep

   ```bash
   grep -L 'key' /path/*.h
   ```

   - -L, --files-without-match: 显示没有匹配的文件
   - -l, --files-with-matches：显示匹配到的文件
   - -c, --count：显示每个文件，匹配到的行数
   -  -v, --invert-match：显示每个不匹配的行





####	78.慢启动如何进行的？

慢启动是TCP连接刚开始时的一种行为：

当TCP连接刚刚建立时，发送方的**拥塞窗口**（Congestion Window，CWND）被设置为一个很小的值，通常为一个报文段的大小，这是为了防止一开始就发送大量的数据导致网络拥塞。

指数增长：在慢启动阶段，每当接收到一个对已发送数据的确认时，拥塞窗口就会**加倍**。这意味着，拥塞窗口的大小会按指数级增长，以快速探测当前网络的可用带宽



发送方需要维护一个叫做==**拥塞窗口cwnd**==的状态变量，其值取决于网络的拥塞程度，并动态变化

- cwnd的维护原则：网络没有出现拥塞，cwnd就增大一些；只要网络出现拥塞，cwnd就减少一些
- 判断出现网络拥塞的依据：没有按时收到应当到达的确认报文（即发送超时重传）

发送方将拥塞窗口作为发送窗口swnd，即 **swnd = cwnd**

发送方需要维护一个叫做==**慢启动阀值ssthresh**==状态变量

- 当 $cwnd < ssthresh$ 时，使用慢启动算法
- 当 $cwnd > ssthresh$ 时，停止使用慢启动算法，改用拥塞避免算法

- 当 $cwnd = ssthresh$ 时，既可使用慢启动算法，也可使用拥塞避免算法



**慢启动算法：**

- 初始时，将cwnd设置为1，并设置ssthresh的初始值
- 发送方收到所有已发送窗口大小的确认报文，将cwnd==翻倍==
- 当cwnd大于ssthresh时，改用拥塞避免算法

***总结：指数增大***



**拥塞避免算法：**

- 发送方每次收到所有已发送窗口大小的确认报文，将cwnd++
- 如果发送拥塞（重传计时器超时），将ssthresh更新为发生拥塞时cwnd值的一半，将cwnd值减少到1，重新开始执行慢启动算法

***总结：加性增加，乘性减少（AIMD）***





####	79.服务端出现大量TIME_WAIT是什么情况

当 TCP 连接主动关闭时，都会经过 TIME_WAIT 状态。

TIME_WAIT 状态存在的意义：

- **保证数据的可靠传输：**如果发送的 LAST ACK 丢失，发送端直接关闭连接。接收端会超时重发，发送端收到一个不存在的连接的包，会响应 RST 包。导致接收端无法正常关闭
- **保证正确处理网络中迟到的数据：**CP 下的 IP 层协议是无法保证包传输的先后顺序的。如果双方挥手之后，一个网络四元组（src/dst ip/port）被回收，而此时网络中还有一个迟到的数据包没有被 B 接收，A 应用程序又立刻使用了同样的四元组再创建了一个新的连接后，这个迟到的数据包才到达 B，那么这个数据包就会让 B 以为是 A 刚发过来的。



出现大量 TIME_WAIT 的服务端，很可能是处理大量短连接的服务器。服务器存在大量处于 TIME_WAIT 状态的 socket，会严重影响服务器的处理能力，甚至耗尽可用的 socket，停止服务。



可能的解决方案：

1. 缩短系统预设 TIME_WAIT 时间
2. 减少短连接
3. 检查代码是否存在资源泄漏



1. **调整操作系统参数**：可以通过修改操作系统的参数来减少TIME_WAIT状态的持续时间，或者调整操作系统的参数以允许更多的端口可用。例如，在Linux系统中，可以通过修改`/etc/sysctl.conf`文件来调整TCP参数。
2. **重用端口**：通过设置`SO_REUSEADDR`套接字选项，可以使端口在TIME_WAIT状态结束后立即可用于新的连接。但是，需要注意的是，这可能会导致某些情况下的连接混乱或不稳定，需要谨慎使用。
3. **优化服务器端程序**：检查服务器端程序是否能够有效地处理连接的关闭，确保及时地释放连接资源，避免长时间的TIME_WAIT状态积累。
4. **使用连接池**：对于频繁建立和关闭连接的情况，可以考虑使用连接池技术，重用已经建立的连接，从而减少TIME_WAIT状态的数量。
5. **升级硬件**：如果服务器的性能受到限制，可以考虑升级硬件，以提高服务器的处理能力，从而更有效地处理连接。



####	80.口述 shell 编程：如何将一个文档最后一行的运算式计算出来（不会）

将文档的最后一行提取出来管道给 bc

1. 使用 awk

   ```bash
   awk 'END {print}' fileName | bc
   ```

   

2. 使用 sed

   ```bash
   sed -n '$p' fileName | bc
   ```



3. 使用 tail

   ```bash
   tail -n 1 fileName | bc
   ```

   

sed：

1. **替换字符串：**

   ```bash
   sed 's/old_string/new_string/g' file.txt
   ```

   这将在文件中查找所有匹配 `old_string` 的地方，并将其替换为 `new_string`。

2. **删除行：**

   ```bash
   sed '/pattern/d' file.txt
   ```

   这将删除包含指定模式的所有行。

3. **打印特定行：**

   ```bash
   sed -n '5p' file.txt
   ```

   这将打印文件中的第五行。

4. **插入和追加行：**

   ```bash
   sed '2a new_line' file.txt	# 在第二行后面添加
   sed '$a new_line' file.txt  # 在文件末尾添加
   sed 'a new_line' file.txt	# 在每一行后面添加
   sed -e '$a new_line' -e '$a new_line' foo # 在文件末尾添加两行
   ```

   这将在第二行之前插入新行或在第二行之后追加新行。

5. **使用正则表达式：**

   ```bash
   sed '/^pattern/s/old_string/new_string/g' file.txt
   ```

   这将仅在匹配正则表达式的行中进行替换。

这只是 `sed` 的基础使用，实际上，`sed` 的命令非常强大，可以进行更复杂的文本处理。可以查阅 `sed` 的文档或使用 `man sed` 命令来获取更详细的信息。



####	两个idc机房互联  你觉得如何做 要用到哪些技术

连接两个不同的IDC（Internet Data Center）机房通常需要使用专门的网络架构和技术，以确保可靠、高效、安全地进行互联。以下是一些可能用到的关键技术和考虑因素：

1. **专线连接：** 使用专线（如光纤、MPLS等）建立高带宽、低延迟的物理连接。专线可以提供更为可靠的连接，相对于公共互联网更具有稳定性和可控性。
2. **VPN（Virtual Private Network）：** 使用VPN技术通过公共互联网建立安全的通信通道。VPN可以提供加密和隧道技术，确保数据在传输过程中的机密性和完整性。常见的VPN协议有IPsec和SSL VPN。
3. **BGP（Border Gateway Protocol）：** 如果涉及到多个网络，使用BGP协议可以实现不同IDC之间的动态路由。BGP允许在不同网络之间自动调整路由，以确保数据以最短的路径传输。
4. **负载均衡：** 在两个IDC之间实现负载均衡，以确保流量在不同连接上平衡分布。这可以通过硬件负载均衡器或软件负载均衡器来实现。
5. **故障转移和冗余：** 在设计中考虑冗余和故障转移机制，以防止单点故障。使用冗余的连接和设备，确保一旦某个连接或设备发生故障，流量能够无缝地切换到备份路径或设备。
6. **QoS（Quality of Service）：** 针对关键应用和服务，实施QoS策略，以确保它们在网络上获得足够的带宽和低延迟，提高服务质量。
7. **安全性：** 使用防火墙、加密和其他安全措施来保护数据在两个IDC之间的传输。确保只有授权的用户和设备能够访问连接。
8. **监控和管理：** 部署监控工具，实时监测两个IDC之间的连接状态和性能。通过监控，及时发现并解决潜在的问题。
9. **法规和合规性：** 确保连接和数据传输满足相关法规和合规性要求，尤其是涉及到用户隐私和敏感数据的情况。
10. **容量规划：** 对连接带宽和设备容量进行充分的规划，以满足未来业务扩展的需求。

这些技术和考虑因素的选择取决于具体的业务需求、预算、安全性要求以及两个IDC的物理位置和网络基础设施。在设计IDC互联方案时，通常需要综合考虑这些因素，以建立稳定、高效、可靠的连接。



####	81.磁盘扇区一般有多大

磁盘一般有三类扇区格式：

1. 512n：支持所有Windows版本
2. 512e：支持所有Windows版本
3. 4Kn：Windows 8 之后，Windows Server 2012 之后

![img](https://www.seagate.com/www-content/ti-dm/_shared/images/ti-transitionadvanced-fig1-600x140.jpg)

原来的磁盘单位（sector format）扇区格式是 512 Bytes，这部分空间不全用来存储数据，还有用于 ECC 校验，Gap，Sync，Address Mark 的代码，这部分功能性代码部分大概占用 60 多 Bytes，故真正的存储空间大概不到 90%。

![img](https://www.seagate.com/www-content/ti-dm/_shared/images/ti-transitionadvanced-fig5-600x125.jpg)

为了提升硬盘容量，硬盘厂商机智地选择把每一个磁盘单位（sector format）扇区格式改为4K（512 Bytes x 8），这种格式又叫做（Advanced Format）高级格式，8个（sector format）共用一个功能性代码部分，这样整体的存储效率自然就大大提高了。据说，4k的空间，存储数字能达到3981Bytes，真正的存储空间使用率能达到97%。

从512到4K的转变，硬盘发生了很大变化，需要操作系统做出很大变化，一瞬间让所有操作系统去适应磁盘的话，那不太可能。作为过渡时期的产物，512e用来将4K的磁盘模拟成512e，e的意思是Emulation，将 4K 的磁盘模拟成 512，让系统以为看见的是512格式的。以上就是512，512e和4K的主要区别。



512e，在模拟 4K 时，数据的写入会比较复杂，严重影响效率。4Kn 的读写效率要比 512e 高。



4Kn 磁盘目前专供服务器市场，消费者可以使用来 PC 内接，NAS，目前市面上所有外接盒产品全不支持 4Kn 磁盘。



有关文章：https://www.seagate.com/blog/advanced-format-4k-sector-hard-drives-master-ti/





####	82.顺序读写和4K读写有何区别

一般是 SSD 中常见概念；

1. 顺序读写：

   是将要集中起来的大数据文件进行连续读写，通常固态硬盘在观看视频或拷贝几十G以上的大文件时，发挥的就是固态硬盘的顺序读写性能。顺序读写侧重数据吞吐量(Throughput)，指单位时间内可以成功传输的数据数量。不同接口和传输协议，顺序读写的理论速度值：SATA、M.2 SATA接口 ，读取速度可达600MB/s，支持NVMe协议的M.2接口、PCIE4.0×4通道，读取速度可达7G/s。

   在所有测试软件中，最高的那个速度成绩，一般被叫做顺序（Sequential，简写为Seq）读取/写入速度，也就是数据都集中在一起、排好了队、按照最优化的速度读写，这是SSD最好的状态。在干净SSD里刚装好的操作系统、大型游戏、大型文件等，在前几次使用时应该能有近似的速度。

2. 随机读写：与之对应的当然就是随机（Random，简写为Ran）读写了，用了一段时间的SSD，大部分数据都零散地存在各个地方，这时体现出的速度就是随机读写了，它当然比顺序读写差一些。杂牌SSD的软件开发能力差，数据整理做得不好，这项得分在使用后会快速下降。

3. 4K读写：

   1. 4K 表示读写操作的块大小，4K 读写性能是评估随机读写性能的重要指标之一。

   2. 4K 读写主要针对小文件的读写性能，小文件一般都是分散的，所以读写速度当然也最差。有些SSD写入时先数据拷贝到高速缓存里，所以速度比读取要更快。在我们打游戏、写Word、做设计的过程中，硬盘更多的工作都是一些小数据的存取，所以这个速度决定了我们使用中是否会有很小的卡顿。

4. IOPS值：在一些测试中还会看到 IOPS 值，它是每秒对SSD的操作数，也影响着数据存取会不会卡顿，比如IOPS很高的话，4K读写速度也自然会比较快一些。为了提升IOPS，SSD大都支持多线程和队列，也就是同时处理多个数据，并且让数据排队。所以线程（T）队列深度（Q）越大，通常 IOPS 和速度也就越高。IOPS 主要用于关注**随机读写**性能的场合，注重每秒对SSD的操作数，在一堆零散的小文件读写上有优势。



####	83.KVM，QEMU，Hyper-V，VMware 这些虚拟化技术有什么区别？这些虚拟化技术的网卡是怎么样的？

hypervision 分为 Type1 和 Type2；

Type1 hypervision：

可以在本地安装并在物理主机上直接运行



1. **KVM（Kernel-based Virtual Machine）：**KVM 是一种基于 Linux 内核的开源虚拟化技术，它允许在 Linux 主机上创建和管理虚拟机，属于一类虚拟化管理程序。![在这里插入图片描述](https://img-blog.csdnimg.cn/674b82652d8940acaaed531259bb1c94.png)
2. **QEMU （Quick Emulator）：**QEMU 是一个开源的虚拟机监控器，它提供了处理器模拟器和设备模拟器，可以模拟多种硬件架构和设备。主要用于模拟硬件。
3. **Hyper-V：**Hyper-V 是由微软开发的虚拟化技术，可以在 Windows Server 和 Windows 操作系统上运行。
4. **VMware：**VMware 是一家知名的虚拟化软件提供商，提供了多种虚拟化解决方案，包括 VMware vSphere、VMware Workstation 等。

QEMU 和 KVM 都是 Linux 环境中常用的开源虚拟化解决方案。 QEMU 是 Quick Emulator 的缩写，是一个通用的开源机器模拟器，可以运行各种操作系统。

KVM（基于内核的虚拟机的缩写）是 Linux 内核的虚拟化基础架构，允许您在单个物理主机上运行多个虚拟机。

QEMU 和 KVM 之间的主要区别在于 QEMU 是基于软件的虚拟化解决方案（类型 2 虚拟机管理程序），而 KVM 是基于硬件的虚拟化解决方案（类型 1 虚拟机管理程序）。这意味着KVM使用主机CPU的硬件虚拟化能力来运行虚拟机，而QEMU则依靠软件模拟来运行虚拟机。

因此，KVM 往往比 QEMU 更高效、更高性能，但也更依赖于硬件。



VirtualBox 和 Hyper-V 是 Windows 环境中常用的专有虚拟化解决方案。

VirtualBox 是 2 类虚拟机管理程序，而 Hyper-V 是 1 类虚拟机管理程序。 VirtualBox 和 Hyper-V 之间的主要区别在于 VirtualBox 是跨平台虚拟化解决方案，而 Hyper-V 仅适用于 Windows。这意味着 VirtualBox 可用于在各种不同的操作系统上运行虚拟机，而 Hyper-V 只能在 Windows 上使用。

另一个区别是 Hyper-V 专为企业使用而设计，而 VirtualBox 更适合个人和小型企业用例。



图中的VMM意为Virtual Machine Monitor，虚拟机监控程序，或者用另一个更专业的名词： **HyperVisor**
从图中可以清楚的看到两种虚拟化方案的区别：
**Type I: 直接凌驾于硬件之上，构建出多个隔离的操作系统环境**
**Type II: 依赖于宿主操作系统，在其上构建出多个隔离的操作系统环境**
我们熟知的VMware事实上有两个产品线，一个是VMware ESXi，直接安装在裸金属之上，不需要额外的操作系统，属于第一类虚拟化。另一个是我们普通用户更加熟知的VMware WorkStation，属于第二类虚拟化。
如何实现上述的虚拟化方案呢？
一个典型的做法是—— `陷阱 & 模拟`技术
什么意思？ **简单来说就是正常情况下直接把虚拟机中的代码指令放到物理的CPU上去执行，一旦执行到一些敏感指令，就触发异常，控制流程交给VMM，由VMM来进行对应的处理，以此来营造出一个虚拟的计算机环境。**
不过这一经典的虚拟化方案在Intel x86架构上却遇到了问题。



####	84.select、poll、epoll的区别和特点

select，poll 和 epoll 都是多用复用 IO 技术，属于同步阻塞模式。可以在单个线程中同时处理多个 I/O 事件。

1. **select:**
   - 使用固定长度的 bitmap，表示 FD 集合，其长度最大值位 1024，只能监听 0 ~ 1023 的 FD。
   - 将 FD 集合拷贝到内核空间中，让内核检查是否有网络事件产生，检查的方式是直接遍历，有事件则将 bitmap 置位，再把 FD 集合拷贝回用户态，用户态还需要通过遍历的方法找到对应的 FD。
   - 每次需要将 bitmap 重新置空，不能重复使用。
2. **poll:**
   - poll 不再使用 bitmap 来存储 FD 集合，而是使用动态数组，以链表形式来组织，突破了 select 的 FD 个数限制。
   - 
3. **epoll:**
   - epoll 在内核里使用红黑树来跟踪进程所有带检测的 FD，把需要监控的 FD 通过 epoll_ctl 函数加入内核中的红黑树里，通过对红黑树操作，就不需要像 select/poll 每次操作时都传入整个 FD 集合，减少了内核和用户空间大量的数据拷贝和内存分配。
   - epoll 使用事件驱动机制，内核里维护了一个双向链表来记录就绪事件，当某个 FD 有事件发生时，通过回调函数，内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait 函数时，只会返回有事件发生的 FD 的个数，不需要像 select/poll 那样轮询整个 FD 集合。
   - epoll 支持两种事件触发模式，分别时边缘触发和水平触发：
     - 使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发⽣时，服务器端只会从 epoll_wait 中苏醒⼀次，即使进程没有调⽤ read 函数从内核读取数据，也依然只苏醒⼀次，因此我们程序要保 证⼀次性将内核缓冲区的数据读取完； 
     - 使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，⽬的是告诉我们有数据需要读取；
   - epoll 是 Linux 特有的，出现在 2.5.x 内核版本中



####	85.epoll模式实现原理？操作系统硬件层面属于同步模型还是异步模型？同步异步区别是什么？



`epoll` 是 Linux 下用于高效事件通知的一种机制，其实现原理基于事件驱动模型。它通过内核提供的三个系统调用 `epoll_create`, `epoll_ctl`, `epoll_wait` 来管理事件，并通过这些系统调用和相关数据结构来实现高效的事件通知。

实现原理如下：

1. **创建 `epoll` 实例**：首先，通过 `epoll_create` 系统调用创建一个 `epoll` 实例，该实例会维护一个事件表。
2. **向 `epoll` 实例注册事件**：通过 `epoll_ctl` 系统调用向 `epoll` 实例注册需要关注的事件，包括读、写等。
3. **等待事件发生**：通过 `epoll_wait` 系统调用等待事件的发生，当有事件发生时，`epoll_wait` 将返回事件的相关信息，包括发生事件的文件描述符等。

![image-20240301204338635](C:\Users\46823\AppData\Roaming\Typora\typora-user-images\image-20240301204338635.png)



epoll 在 IO 层面属于同步模型，在消息处理层面属于异步模型。



同步模型和异步模型的区别在于事件的处理方式：

- **同步模型**：在同步模型中，事件的发生会导致线程的阻塞，直到事件得到处理为止。在这种模型下，一个线程通常只能处理一个事件，如果有多个事件同时发生，就需要创建多个线程来处理。
- **异步模型**：在异步模型中，事件的发生不会导致线程的阻塞，而是通过回调机制通知应用程序，从而使得应用程序能够继续执行其他任务。在这种模型下，一个线程可以同时处理多个事件，从而提高了并发性和性能。





####	86.子网划分问题

![image-20240305163530479](C:\Users\46823\AppData\Roaming\Typora\typora-user-images\image-20240305163530479.png)

答案为 C



![image-20240305164248965](C:\Users\46823\AppData\Roaming\Typora\typora-user-images\image-20240305164248965.png)



####	87.常见端口号

| 服务   | 端口号 | 传输协议 |
| ------ | ------ | -------- |
| FTP    | 20，21 | TCP      |
| SSH    | 22     | TCP      |
| Telnet | 23     | TCP      |
| DNS    | 53     | UDP      |
| POP3   | 110    | TCP      |
| IMAP4  | 143    | TCP      |
| SNMP   | 161    | UDP      |
| DHCP   | 67     | UDP      |
| NTP    | 123    | UDP      |





####	88.零碎知识点

![image-20240305165719239](C:\Users\46823\AppData\Roaming\Typora\typora-user-images\image-20240305165719239.png)

![image-20240305165743711](C:\Users\46823\AppData\Roaming\Typora\typora-user-images\image-20240305165743711.png)



![image-20240305165755070](C:\Users\46823\AppData\Roaming\Typora\typora-user-images\image-20240305165755070.png)



####	服务器和家用PC之间有什么不同

企业级服务器一般包括以下功能：

- 热插拔磁盘驱动器
- 热插拔电源
- 热插拔冷却装置
- 以及更昂贵配置中的热插拔内存板

服务器和家用PC有非常多的区别，比如：

- 内存不同：服务器和图形工作站一般使用ECC内存（应用了错误检查和纠正技术的内存），这将使整个电脑系统在工作时更趋于安全稳定。
- 电源不同：服务器一般是热插拔





####	epoll 惊群的原理



####	两地三中心是什么

1. 两地：同城，异地
2. 三中心：生产中心，同城容灾中心，异地容灾中心



####	vlan，dhcp  概念

vlan：在二层进行隔离

dhcp：动态分配 IP 地址





####	虚拟化了解哪些，家用cpu 和服务器cpu的不同地方，说几个服务器cpu型号







####	进程的三种状态

就绪，运行，阻塞



####	进程间通信方式

1. 管道
2. 共享内存
3. 信号
4. 信号量
5. 消息队列
6. socket



####	线程的调度方式，进程的调度方式有哪些

抢占式和非抢占式，多级反馈队列。



####	Shell 脚本中的判断语句

shell 中的 if 语句中，分为以下几类：

- **通过命令的返回值作为 *condition*：**

  ```bash
  if command; then
  	....
  fi
  ```

- **使用 *test* 命令：**

  ```bash
  if test condition; then
  	....
  fi
  ```

- **使用 *[ ]*：**

  *[ ]* 支持和 *test* 一样的判断方式，主要有数字比较、字符串比较、文件比较。

  同时还支持条件测试：

  ```bash
  [condition1] || [condition2]
  [condition1] && [condition2]
  ```

- **使用 *[[ ]]*：**

  *[[ ]]* 方式是 bash 的扩展，原始的 sh 不一定支持。提供了模式匹配、正则表达式匹配等高级功能。

  ```bash
  # 模式匹配 (glob Unix 的通配符)
  if [[ $file == *.txt ]]; then
  	echo "The file is a text file."
  fi
  
  # 正则表达式匹配 =~
  string="Hello, World!"
  if [[ $string =~ ^[A-Za-z]+,[[:space:]]([A-Za-z]+)~$ ]]; then
  	echo "String matches the pattern."
  fi
  
  # 双括号中的字符串比较，不需要使用转义字符
  if [[ $str1 < $str2 ]]; then
  	...
  fi
  ```

  根据前人经验，双括号一般用于字符串和文件，如果需要比较数字，尽量使用 *(( ))*。

  如果考虑可移植性和兼容性，则应该使用旧语法。新语法功能强，但在某些地方可能存在歧义。

  ![image-20250217111733015](C:\Users\46823\AppData\Roaming\Typora\typora-user-images\image-20250217111733015.png)

####	Shell 脚本中的循环语句

shell 中的循环语句，主要有：

- **for 循环：**

  ```bash
  for var in list; do
  	....
  done
  ```

- ***C-style* for 循环：**

  ```bash
  for(( var1=1, var2=2; var1<=10; ++var1, ++var2 )); do
  	....
  done
  ```

- **while 循环：**

  ```bash
  while test condition; do
  	....
  done
  ```

一般来说，如果正在迭代列表（参数、文件名、数组元素等），则使用 `for`。如果没有列表，则使用 `while`。

需要注意几点：

1. for 循环中，如果省略 `in LIST`，则假定为 `in "$@"`。

实际例子：

解析 `/etc/passwd`，提取用户名、UID 和 GID 并打印。

```bash
while IFS=: read -r user pwdhash uid gid _; do
  echo "user $user has UID $uid and primary GID $gid"
done < /etc/passwd
```





###	Shell 脚本的输入和输出

Shell 脚本中的输入和输出是一个复杂的主题，因为它的完成方式有很大的灵活性。

*Input* 输入可以来自：

- 命令行参数（位置参数）
- 环境变量，从启动脚本的任何进程继承
- 文件
- *File Descriptor* 可以指向的任何其他内容（如管道、终端、套接字等）

*Output* 写入可以来自：

- 文件
- File Desriptor 可以指向的任何其他内容
- 其他程序的命令行参数
- 传递给其他程序的环境变量



1. **命令行参数**

   对于大多数脚本来说，首先关心的输入是脚本在命令行接收的参数，即位置参数。

   - **单次引用:** 可以通过`$1`、`$2` 来单次引用。
   - **整体引用:** 通过`"$@"`来引用整个位置参数集合。这里的双引号非常重要，如果不用双引号，则每个位置参数都将进行统配或*word splitting*。
   - ***shift* 内置命令:** 使用该命令，第一个位置参数将消失，第二个位置参数变为第一个，后续依次类推，类似于向左平移。

   使用 *getopts* bash内置命令来处理命令行参数：

   - OPTARG
   - OPTINT

2. 





####	Shell 脚本的重定向

临时重定向：

- **重定向 *stdout、stdin*：**

  ```bash
  a > b  == a 1> b
  a < b == a 0<1 b
  ```

- **重定向 *stderr*：**

  ```bash
  # 将 stderr 重定向到文件
  a 2> b
  # 将 stdout 重定向到 stderr
  a >&2 b
  ```

- **将 *stdout* 和 *stderr* 都重定向到文件中：**

  ```bash
  # 不可移植，仅限 Bash
  a &> b
  # 可移植
  a > b 2>&1 
  ```

- **重定向 *stdout* 到文件中，*stderr* 到 *stdout*：**

  ```bash
  a 2>&1 > b
  ```

- ***Here Document*：**

  ```bash
  cat <<EOF
  	.....
  EOF
  
  cat <<-EOF	# 忽视每行开头的制表符
  	.....
  EOF
  ```

- ***Here String*：**

  ```bash
  # stdin 直接读取 <<< 后面的句子
  grep pattern <<< "target string"
  ```

- **管道 *piple*：**

  管道运算符为每个命令创建一个子shell环境。理解这一点很重要，因为在第二个命令内修改或初始化任何变量在其外部都将显式为未修改。

  ```bash
  # 管道同时传递 stdout 和 stderr
  ls /nonexistent / |& tee output.log
  ```

  `|&` 等价于 `2>&1 |`，即让 *stderr* 也进入管道

  结论：

  ✅ **`2>`** → **只重定向标准错误**，适合存日志
  ✅ **`>&2`** → **把标准输出变成标准错误**，适合脚本调试
  ✅ **`2>&1`** → **合并标准输出和错误输出**，最常用
  ✅ **`|&`** → **让 stderr 也进入管道**，适合 `grep` 过滤



####	Shell 脚本中的变量类型

Bash 有几种类型的变量：

- **字符串变量：**默认变量，如 `a=b`，那么就创建了一个名为 a 且内容为 b 的字符串变量。
- **环境变量：**从父进程继承并传递给子进程的字符串变量，它们通常都是大写的。
- **数组变量：**具有非负整数索引，并保存字符串。
- **关联数组变量：**具有字符串索引，并保存字符串，类似 Python 字典。

主要注意的几点：

1. 数组可以在没有任何特殊声明的情况下创建，如：`a=(this is an array)` 或 `a[42]=foo`

2. 关联数组必须提取声明：`declare -A hash`。函数内声明则会创建一个具有局部范围的变量。

3. 数组无法导出到环境中，只有字符串可以。请记住，环境是整个系统上每个程序可能使用的 key=value 对的列表。



####	说一下 Shell 中的特殊变量

- `$#`：传递给该脚本的参数个数
- `$0`：脚本本身的名字
- `$1 ~ $9`：传递给该shell脚本的第1到第9个参数
- `$@`：传递给脚本所有参数所组成的列表
- `$*`：以“参数1 参数2 ....”的形式返回所有参数
- `$_`：最后一个位置参数
- `$?`：最后命令的退出状态
- `$$`：脚本运行的当前进程号
- `$!`：最近启动的后台进程的 PID
- `!!`：重复执行最后一次运行的命令
- 



####	说一下 Shell 中的算数，支持浮点计算吗

Bash 可以进行整数运算，但不能进行浮点运算。算术表达式是由类似 C 的表达式解析器在算术上下文中计算的任何内容。最基本的数学上下文是 `$(( ))` *算术替换*：

```bash
x=$(( y + z ))
```

在数学上下文中，解析规则非常不同。空格是无关紧要的，变量扩展不需要`$`。且在上下文中将进行递归运算。索引数组的索引周围的括号也是一个数学上下文，运行编写类似 `"${arr[i+1]}"` 的内容。

算数命令是一种算术表达式，用于命令通常出现的位置。它具有退出状态。故可以用于 `if` 或 `while` 语句中：

```bash
if (( x < 4 ));	then echo "too small, try again"; fi
```

另外注意，数学上下文中的大部分规则遵循 C 语言规则。前导 *0x* 的数字是十六进制的，前导 *0* 是八进制。所有其他整数都被视为以 10 为基数，除非以 `base#` 为前缀。





####	描述session工作原理，如果禁止cookie，session还能用吗

Session 是一种在 Web 开发中用于跟踪用户状态的机制。它通过在服务器端存储用户信息，为每个用户分配一个唯一的标识符，然后将该标识符发送给客户端。常见的实现方式包括使用 Cookie 或者 URL 重写。

**Session 的工作原理：**

1. **会话的启动：** 当用户首次访问一个需要进行会话跟踪的网站时，服务器会为该用户创建一个唯一的会话标识符（Session ID）。
2. **存储信息：** 服务器端根据该会话标识符创建一个对应的数据存储区域，用于存储用户的状态信息（例如登录状态、购物车内容等）。
3. **发送标识符给客户端：** 服务器将该会话标识符发送给客户端。通常，这是通过 Cookie 或者 URL 重写的方式完成的。如果使用 Cookie，会话标识符会被存储在客户端的 Cookie 中，并在后续的请求中被发送给服务器。
4. **请求时的标识符验证：** 在用户的后续请求中，客户端会将之前获得的会话标识符发送给服务器。服务器通过这个标识符找到对应的会话数据存储区域，以还原用户的状态信息。
5. **会话的结束：** 会话可以在用户关闭浏览器时结束，或者在一定时间内没有活动时自动结束。一旦会话结束，相关的状态信息也会被清理。

如果禁止了使用 Cookie，可以采用其他方式实现 Session，其中最常见的是 URL 重写。在 URL 重写的方式下，会话标识符会出现在每个链接中，以便在用户点击链接时将会话标识符传递给服务器。例如：

```
http://example.com/page?session_id=abcd1234
```

这种方式的缺点包括：

- **安全性较差：** 会话标识符暴露在 URL 中，可能被恶意用户或代理服务器记录或截取。
- **链接的美观性：** URL 中带有会话标识符可能导致链接相对较长，不太美观。

尽管可以使用 URL 重写方式，但一般而言，使用 Cookie 是更为常见和方便的方法。如果禁用了 Cookie，并且采用 URL 重写方式也不可行，那么需要考虑其他替代方案或者重新评估是否完全禁用 Cookie 的必要性。







###	Docker 和 K8S 相关问题

####	系统访问量/并发高，使用什么技术解决？

1. **负载均衡：** 使用负载均衡技术将流量分发到多个服务器上，以防止单一服务器成为瓶颈。常见的负载均衡器包括Nginx、HAProxy和硬件负载均衡器。
2. **缓存：** 使用缓存可以显著减轻数据库和其他资源的压力。可以考虑使用缓存来存储频繁访问的数据，例如使用内存缓存系统（如Redis或Memcached）。
3. **CDN（内容分发网络）：** 利用CDN将静态资源分发到全球各地的服务器，从而减少用户访问时的延迟。CDN 可以提高页面加载速度并减轻原始服务器的负载。
4. **水平扩展：** 将系统架构设计为可水平扩展，以便能够在需要时添加更多的服务器。云服务提供商通常提供自动水平扩展功能，可以根据需求自动添加或删除服务器。
5. **数据库优化：** 对数据库进行优化是确保系统性能的关键一步。可以通过合理的索引设计、查询优化、分区和缓存来提高数据库性能。
6. **异步处理：** 使用异步处理技术来处理一些非实时、耗时的任务，以减轻主要服务的负担。消息队列（例如RabbitMQ、Kafka）和后台任务队列（例如Celery）是处理异步任务的常见工具。
7. **反向代理：** 使用反向代理服务器（例如Nginx、Apache）来处理客户端请求，可以提供一些安全性和性能方面的优势，并缓解一些直接传递到应用服务器的压力。
8. **自动化监控和调整：** 设置监控系统，实时监测系统的性能和健康状况。使用自动化工具根据需求调整资源，例如自动扩展和缩减服务器数量。
9. **容器化和微服务：** 将应用程序拆分成小的独立服务，使用容器技术（例如Docker）进行部署。这样可以更容易地进行扩展、升级和管理。
10. **内容优化：** 通过优化页面和资源，减少页面加载时间，从而减轻服务器负载。压缩和合并CSS、JavaScript文件，使用适当的图片压缩技术等都是优化手段。



####	docker部署的网络模式有哪些？

1. **桥接模式：**

   这是Docker默认的网络模式，内部的容器之间可以相互通信。

   ```bash
   docker run --network bridge my-container
   ```

2. **主机模式**

   容器直接使用主机的网络栈，与主机共享网络命名空间。这样可以提高容器访问网络的性能，但容器的端口将直接映射到主机上，可能会产生端口冲突。

   ```bash
   docker run --network host my-container
   ```

3. **无网络模式**

   在无网络模式下，Docker 容器没有自己的网络栈，不与任何网络相连。这样的容器通常用于排除网络访问，只依赖本地文件系统的场景。

   ```bash
   docker run --network none my-container
   ```

   

4. **Overlay 模式**

   Overlay 网络允许通过在多个 Docker 主机上运行的容器之间创建安全的、跨主机的网络。这对于在集群中运行分布式应用程序非常有用。

   ```bash
   docker network create --driver overlay my-overlay-network
   docker service create --network my-overlay-network my-service
   ```

5. **Macvlan 模式**

   Macvlan 允许将容器连接到网络中，并且每个容器都有自己的 MAC 地址。这使得容器可以像物理设备一样直接与网络通信。

   ```bash
   docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=eth0 my-macvlan-network
   docker run --network my-macvlan-network my-container
   
   ```

   

6.写一下代码吧  链表的增删改查

7.git 的用法？

场景题，如何设计一个高可用的系统，流量快到阈值了怎么处理

是否了解nginx负载均衡



3.docker怎么包含最小化的操作系统镜像？

5.nginx正向和反向代理

8.mysql的部署模式有哪些？

5、Docker在不同CPU上如何进行迁移

如果你的项目要上线，可能会有上万个用户使用，该怎么去改进

页表默认大小是多少

2.虚拟地址如何映射到物理内存的9.多线程实现的原理
10.中断了解吗
11.说说线程池
12.死锁如何避免

kubernetes  master   node   pod  deployment 请讲下他们的概念

网络插件calico 和flannel 有什么不同。

Windows操作系统的域控，组策略

k8s中如何进行日志监控



####	Kubernetes滚动更新策略的原理，在部署中的作用和如何实现滚动更新



####	如果k8s集群外部需要访问node里的pod如何操作

可以使用 K8s Service 的 NodePort 类型 或者通过 Ingress 进行暴露

1. **使用 NodePort**：

   NodePort 是 Kubernetes Service 的一种类型，它会将 Pod 暴露到集群的每个 Node 上的固定端口上。你可以通过 Node 的 IP 地址和分配的端口来访问 Service。

   1. 创建 NodePort 类型的 Service：

      ```yaml
      apiVersion: v1
      kind: Service
      metadata:
        name: my-service
      spec:
        type: NodePort
        selector:
          app: your-app-label
        ports:
        - protocol: TCP
          port: 80       	  # Service 暴露的端口
          targetPort: 8080  # Pod 中容器的端口
          nodePort: 30000   # NodePort 的端口，可以根据需要选择
      
      ```

   2. 通过 Node 的 IP 地址和 NodePort 进行访问：

      ```bash
      curl http://<Node-IP>:30000
      ```

2. **使用 Ingress：**

   Ingress 是 Kubernetes 中的 API 对象，它允许你定义外部访问规则，包括主机名和路径。使用 Ingress 控制外部流量的路由。

   1. 创建 Ingress 资源：

      ```yaml
      apiVersion: networking.k8s.io/v1
      kind: Ingress
      metadata:
        name: my-ingress
      spec:
        rules:
        - host: your-domain.com  # 可以是你的域名
          http:
            paths:
            - path: /
              pathType: Prefix
              backend:
                service:
                  name: your-service
                  port:
                    number: 80
      ```

      请将上述 YAML 文件中的 `host: your-domain.com` 替换为你的域名，并将 `service.name: your-service` 替换为你的 Service 的名称。

   2. 配置域名解析：

   3. 通过域名进行访问：

   







####	k8s亲和性调度讲解一下



####	k8s的deployment和replicaset区别（完了，唯一一个运维相关实际问题没答上）

在 Kubernetes 中，Deployment 和 ReplicaSet 都是用于管理 Pod 副本的控制器，但它们在功能和用途上有一些区别。

**ReplicaSet:**

1. **功能**:
   - ReplicaSet 是 Kubernetes 早期版本中用于定义和维护 Pod 副本数量的资源。
   - 它确保在集群中运行指定数量的 Pod 副本，通过在需要时创建或删除 Pod 来维护期望的副本数。
2. **选择器（Selector）**:
   - ReplicaSet 使用标签选择器来确定管理哪些 Pod。只有符合选择器的 Pod 才会受到 ReplicaSet 的管理。
3. **更新策略**:
   - ReplicaSet 支持滚动更新，即逐步替换现有的 Pod，确保在整个过程中不中断服务。

**Deployment:**

1. **功能**:
   - Deployment 是在 ReplicaSet 的基础上提供的更高级的控制器，用于声明式地定义应用的部署。
   - 它允许用户以声明式的方式定义期望的应用状态，而不需要关心底层的 ReplicaSet。
2. **声明式配置**:
   - Deployment 允许用户通过声明式配置定义应用的期望状态，而不是手动管理每个 ReplicaSet。
   - 用户可以指定副本数、更新策略、滚动更新的速率等。
3. **版本控制**:
   - Deployment 支持应用版本控制，可以轻松地进行应用的回滚或升级。
4. **滚动更新**:
   - Deployment 提供了滚动更新的机制，以确保在更新过程中不会导致整个应用的中断。

综上所述，ReplicaSet 更加底层，主要关注于 Pod 副本的数量和选择器的匹配。而 Deployment 则是更高层次的抽象，提供了声明式的配置方式和更多高级的管理功能，适用于应用的部署和更新。在实际使用中，一般推荐使用 Deployment 来管理应用的副本。Deployment 的变更会触发创建新的 ReplicaSet，并进行滚动更新。



####	k8s有哪些组件，作用

1. **kube-apiserver**:
   - 作用：提供 Kubernetes API 的服务，是 Kubernetes 集群控制平面的前端。
   - 说明：所有的操作和集群状态的查询都通过 kube-apiserver 进行。
2. **etcd**:
   - 作用：分布式键值存储，用于存储集群的配置数据和元数据。
   - 说明：etcd 是 Kubernetes 集群的数据存储后端，保存了整个集群的状态。
3. **kube-controller-manager**:
   - 作用：运行控制器，监视集群状态，并根据需要进行集群状态的调整。
   - 说明：包含多个控制器，如 Node 控制器、Replication Controller 等。
4. **kube-scheduler**:
   - 作用：负责 Pod 的调度，将 Pod 分配到合适的 Node 上运行。
   - 说明：根据一些策略（如资源需求、亲和性和反亲和性规则等）选择最优的 Node。
5. **kubelet**:
   - 作用：在每个 Node 上运行，负责维护容器的生命周期，与容器运行时通信。
   - 说明：kubelet 通过 API Server 接收 PodSpec，确保 Pod 中描述的容器正常运行。
6. **kube-proxy**:
   - 作用：负责维护网络规则，使得 Pod 可以相互通信。
   - 说明：kube-proxy 在每个 Node 上运行，为 Service 提供了一个抽象层，负责 Pod 的网络代理。
7. **Container Runtime**:
   - 作用：负责容器的实际运行，如 Docker、containerd 等。
   - 说明：Kubernetes 可以与多种容器运行时进行集成，通过 CRI（Container Runtime Interface）来实现。
8. **kubectl**:
   - 作用：命令行工具，用于与 Kubernetes 集群进行交互。
   - 说明：kubectl 提供了管理集群、部署应用、查看资源状态等功能。
9. **CoreDNS** (可选)：
   - 作用：提供集群中的 DNS 服务，用于服务发现。
   - 说明：CoreDNS 用于解析服务名称到对应的 IP 地址。
10. **Ingress Controller** (可选)：
    - 作用：处理 Ingress 资源，允许外部流量访问集群内的服务。
    - 说明：Ingress Controller 通过定义 Ingress 资源规则，实现 HTTP 和 HTTPS 流量的路由。
11. **Pod**:
    - 作用：Kubernetes 最小的可部署单元，包含一个或多个容器。
    - 说明：Pod 中的容器共享网络和存储，是 Kubernetes 部署和扩展的基本单元。



####	算是比较基础的k8s的问题，一些组件的作用，集群中网络，存储的一些基础知识。在回答的同时，我还补了一些底层原理的东西





虚拟机机装lInux的过程:节点怎么分配网络地址?

TCP三次握手四次挥手，为什么要三次握手，四次挥手的最后一次为什么要等待

进程间通信方式

1. **管道（Pipes）**：管道是一种在父进程和子进程之间或者在兄弟进程之间进行通信的方式。Linux 中有两种类型的管道：有名管道（FIFO）和无名管道。无名管道通常用于在父子进程之间传递数据。
2. **消息队列（Message Queues）**：消息队列是一种通过消息进行通信的 IPC 机制，允许进程向队列中发送和接收消息。这些消息可以具有不同的格式和优先级。
3. **信号（Signals）**：信号是一种异步通信机制，通常用于通知进程发生了某个事件。Linux 提供了一系列标准信号，如 SIGINT（中断）和 SIGTERM（终止），以及用户自定义信号。
4. **共享内存（Shared Memory）**：共享内存允许多个进程在它们之间共享同一块内存区域。这使得进程可以直接读写这块内存，因此效率非常高。
5. **信号量（Semaphores）**：信号量是一种同步机制，通常用于控制多个进程对共享资源的访问。信号量可以被用来避免竞态条件和实现进程同步。
6. **套接字（Sockets）**：套接字是用于网络通信的通用 IPC 机制，但它也可以用于本地进程间通信。Unix 套接字（Unix Domain Socket）是一种在同一台机器上的进程间进行通信的方式。
7. **文件（File）**：进程可以通过读写文件来进行通信。这可以是一种简单的方式，但需要实施同步和互斥控制，以确保多个进程之间的一致性。
8. **RPC（Remote Procedure Call）**：RPC 是一种进程间通信的方式，允许一个进程调用另一个进程中的函数或过程，就像本地调用一样。这通常用于分布式系统和客户端-服务器模型。









进程和线程区别，多进程和多线程有什么区别，什么时候用多线程什么时候用多进程，优势劣势是什么？

 MySQL的主从复制

MySQL的慢查询优化

对运维的理解是什么，运维会用到哪些工具

Linux如何查看资源占用、杀死进程

网络数据包的格式

Linux内核了解嘛

Docker底层原理



客户保密项目去机房做配置有什么需要注意的?



访问一个负载均衡服务器是如何把请求给处理服务器的。

用过哪些存储，具体说一下，我说的是iscsi，大概是怎么配置iscsi的，怎么进入iscsi

虚拟化用过哪些，虚拟平台搭建过哪些，ESXI要创建一个虚拟机的步骤是什么创建虚拟机还需要配置什么



你使用ansible主要操作了什么;实现了什么

vlan，trunk的区别

如何查看网卡实时信息

MySQL数据库是自己搭建的吗? 搭建过集群吗?

数据库主从同步如何进行，异步，半同步的区别是什么



nginx的基本原理和作为反向代理服务器的优势





21、docker的配置，如何进入docker；如何在服务器中查看配置了哪些容器

mysql慢sql要怎么优化（我只回答了加索引，但实际上还有很多办法但我没印象）





nginx的负载均衡和反向代理，常用模块介绍



3、抓项目问，问虚拟化的方案

8、linux中间件：nginx的搭建方案，作用是什么；mysql的搭建，主从



1.查看进程端口号: netstata   ss   lsof
4.MySQL什么场景下使用大数据什么场景下使用小数据？

7.是否知道一个neginx如何支持两个网站



线程上下文切换一定比协程优雅吗

操作系统中死锁的处理策略？

操作系统的内存寻址过程



假设你家里人给你打电话说上不了百度了，你会怎么排查网络



报数游戏，我两顺着报数，可以报一个数，也可以报两个数，比如说我开始可以报1，你可以报2，或者报2，3；我接下来也可以选择报一个数或两个数，有没有什么必赢的办法，谁先报到30谁赢？



翻牌子，开始有一堆41-50 的卡牌正面朝下，能被1整除的翻一次，能被2整除的翻一次，能被3整除的翻一次，一直到100，请问选哪张卡牌可以保证最后正面朝上？

http的get和post

